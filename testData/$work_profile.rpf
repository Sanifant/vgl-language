{******************************************************************************
*
* Module Name   : $WORK_PROFILE.RPF
*
* Purpose       : Allow modification of the component/limit details of a specification.
*
* Document Ref. :
*
* Specification :
*
* Portability   : Not Checked
*
* Re-entrant    :
*
*******************************************************************************}

SET COMPILE_OPTION DECLARE
ENABLE WINDOWS
SET NAME "DEFER/"
SET NOTPROTECTED

JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $LIB_GRID
JOIN LIBRARY $LIB_UNIT
JOIN LIBRARY $LIMIT_MOD
JOIN LIBRARY $LEVEL_MOD
JOIN LIBRARY $LIB_FILTR
JOIN LIBRARY $LAB_USER
JOIN LIBRARY $LIB_COMP
JOIN LIBRARY $MLPS

JOIN STANDARD_LIBRARY STD_UTILS
JOIN STANDARD_LIBRARY STD_PROMPT
JOIN STANDARD_LIBRARY STD_CLASS
JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_DATABASE
JOIN STANDARD_LIBRARY STD_MESSAGE


CONSTANT WORK_PROFILE_ENTRY          = "WORK_PROFILE_ENTRY"
CONSTANT WORK_PROFILE_GRID           = "WORK_PROFILE_GRID"
CONSTANT WORK_PROFILE_ANALYSIS       = "WORK_PROFILE_ANALYSIS"
CONSTANT WORK_PROFILE_COMPONENT      = "WORK_PROFILE_COMPONENT"
CONSTANT WORK_PROFILE_SCHEDULE       = "WORK_PROFILE_SCHEDULE"
CONSTANT WORK_PROFILE_INSERT_FORM    = "WORK_PROFILE_INSERT_FORM"
CONSTANT WORK_PROFILE_PROMPT_CONTROL = "WORK_PROFILE_PROMPT_CONTROL"

CONSTANT PROMPT_ON_SCHEDULE      = "S"
CONSTANT PROMPT_ON_ANALYSIS      = "A"
CONSTANT PROMPT_ON_COMPONENT     = "C"
CONSTANT PROMPT_ON_LEVEL         = "L"
CONSTANT PROMPT_ON_TEXTUAL       = "T"


CONSTANT LEVEL_COMMAND_INSERT = "I"
CONSTANT LEVEL_COMMAND_MOVE   = "M"
CONSTANT LEVEL_COMMAND_DELETE = "D"


DECLARE work_profile_prompt_details      ,
	work_profile_propagate           ,
	work_profile_entries             ,
	work_profile_level_entry_code    ,
	work_profile_levels              ,
	work_profile_deleted_analyses    ,
	work_profile_other_fields        ,
	work_profile_all_locked          ,
	work_profile_places_browse_array ,
	nothing { Used to make prompts visible on grid }

EXIT


{******************************************************************************}

ROUTINE work_profile_initialise ( VALUE is_batch )

{
*
*
*******************************************************************************}

	IF NOT global ( "LIBRARY_INITIALISED" ) THEN

		lib_grid_initialise  ()
		unit_prompt_initialise ()
		lib_comp_initialise ()

		work_profile_define_class ()
		work_profile_define_prompt_details ( is_batch )

		ARRAY work_profile_places_browse_array ARRAY_SIZE ( 11 , 2 )

		work_profile_places_browse_array [ 1 , 1 ] = "X"
		work_profile_places_browse_array [ 1 , 2 ] = "X"

		work_profile_places_browse_array [ 2 , 1 ] = "0"
		work_profile_places_browse_array [ 2 , 2 ] = "0"

		work_profile_places_browse_array [ 3 , 1 ] = "1"
		work_profile_places_browse_array [ 3 , 2 ] = "1"

		work_profile_places_browse_array [ 4 , 1 ] = "2"
		work_profile_places_browse_array [ 4 , 2 ] = "2"

		work_profile_places_browse_array [ 5 , 1 ] = "3"
		work_profile_places_browse_array [ 5 , 2 ] = "3"

		work_profile_places_browse_array [ 6 , 1 ] = "4"
		work_profile_places_browse_array [ 6 , 2 ] = "4"

		work_profile_places_browse_array [ 7 , 1 ] = "5"
		work_profile_places_browse_array [ 7 , 2 ] = "5"

		work_profile_places_browse_array [ 8 , 1 ] = "6"
		work_profile_places_browse_array [ 8 , 2 ] = "6"

   		work_profile_places_browse_array [ 9 , 1 ] = "7"
		work_profile_places_browse_array [ 9 , 2 ] = "7"

		work_profile_places_browse_array [ 10 , 1 ] = "8"
		work_profile_places_browse_array [ 10 , 2 ] = "8"

		work_profile_places_browse_array [ 11 , 1 ] = "9"
		work_profile_places_browse_array [ 11 , 2 ] = "9"

		SET GLOBAL "LIBRARY_INITIALISED" TO TRUE

	ENDIF

	limit_mod_initialise ()
	level_mod_initialise ()

	ARRAY work_profile_deleted_analyses


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_define_class

{
*
*
*******************************************************************************}

	DEFINE CLASS WORK_PROFILE_ENTRY

		PROPERTIES "ANALYSIS"         ,
			   "ANALYSIS_VERSION" ,
			   "SCHEDULE"         ,
			   "COMPONENT_LIST"   ,
			   "COMPONENT"        ,
			   "COMPONENT_ORDER"  ,
			   "REPLICATES"       ,
			   "LEVEL"            ,
			   "LIMITS"           ,
			   "DP"               ,
			   "UNITS"            ,
			   "IS_STANDARD"      ,
			   "ENTRY_CODE"       ,
			   "COMPONENT_TYPE"   ,
			   "TEXTUAL_VALUE"    ,
			   "COMPARISON"       ,
			   "OTHER_FIELDS"     ,
			   "ACTUAL_ANALYSIS"  ,
			   "ACTUAL_COMPONENT"

		ACTIONS    "IS_ANALYSIS"    ,
			   "IS_SCHEDULE"    ,
			   "IS_COMPONENT"   ,
			   "IS_LEVEL"       ,
			   "IS_TEXTUAL"     ,
			   "IS_TYPE"        ,
			   "READ_OTHERS"    ,
			   "WRITE_OTHERS"   ,
			   "PRINT_OTHERS"

		INITIALISATION

	END CLASS

	DEFINE CLASS WORK_PROFILE_GRID

		INHERIT    "STD_GRID_EDITOR"

		PROPERTIES "ENTRIES"          ,
			   "DELETED_ANALYSES" ,
			   "LEVEL_ENTRY_CODE" ,
			   "LEVELS"           ,
			   "INSERT_ANALYSIS"  ,
			   "IS_BATCH"         ,
			   "MODE"

	END CLASS

	DEFINE CLASS WORK_PROFILE_ANALYSIS

		PROPERTIES "ANALYSIS"         ,
			   "ANALYSIS_VERSION" ,
			   "COMPONENT_LIST"   ,
			   "POSITION"         ,
			   "NOT_UPDATED"      ,
			   "ORDER_NUMBER"

	END CLASS

	DEFINE CLASS WORK_PROFILE_COMPONENT

		PROPERTIES "COMPONENT"        ,
			   "POSITION"         ,
			   "ORDER_NUMBER"     ,
			   "NOT_UPDATED"

	END CLASS

	DEFINE CLASS WORK_PROFILE_SCHEDULE

		PROPERTIES "SCHEDULE"     ,
			   "ORDER_NUMBER" ,
			   "NOT_UPDATED"  ,
			   "REPLICATES"

	END CLASS

	DEFINE CLASS WORK_PROFILE_INSERT_FORM

		INHERIT PROMPT_CLASS_FORM

		PROPERTIES "ANALYSIS"           ,
			   "SCHEDULE"           ,
			   "COMPONENT"          ,
			   "TEXTUAL"            ,
			   "INSERT_ALL_CATS"    ,
			   "INSERT_READING_CAT"	,
			   "ADD_ANALYSIS"       ,
			   "ADD_SCHEDULE"       ,
			   "ADD_COMPONENT"      ,
			   "ADD_ALL_COMPONENTS" ,
			   "ADD_TEXTUAL"

	END CLASS

	DEFINE CLASS WORK_PROFILE_PROMPT_CONTROL

		PROPERTIES "TABLE"          ,
			   "FIELD"          ,
			   "ALLOWED_FOR"    ,
			   "TITLE"          ,
			   "POSITION"       ,
			   "WIDTH"

		ACTIONS    "PROMPT_ON_SCHEDULE"  ,
			   "PROMPT_ON_ANALYSIS"  ,
			   "PROMPT_ON_COMPONENT"

		INITIALISATION

	END CLASS

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_prompt_control_class_initialisation ( self )

{
*
*
*******************************************************************************}

	self . table       = EMPTY
	self . field       = EMPTY
	self . allowed_for = ""
	self . title       = ""
	self . position    = 0
	self . width       = 0

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_prompt_control_action_prompt_on_schedule ( self )

{
*
*
*******************************************************************************}

	self . allowed_for = self . allowed_for : PROMPT_ON_SCHEDULE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_prompt_control_action_prompt_on_analysis ( self )

{
*
*
*******************************************************************************}

	self . allowed_for = self . allowed_for : PROMPT_ON_ANALYSIS

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_prompt_control_action_prompt_on_component ( self )

{
*
*
*******************************************************************************}

	self . allowed_for = self . allowed_for : PROMPT_ON_COMPONENT

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_define_prompt_details ( VALUE is_batch )

{
*
*
*******************************************************************************}

	DECLARE other       ,
		next_prompt


	next_prompt = 1

	ARRAY work_profile_prompt_details ARRAY_SIZE ( 0 , 7 )
	ARRAY work_profile_other_fields
        ARRAY work_profile_propagate

	IF NOT is_batch THEN

		work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
		work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
		work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_TYPE"
		work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_TYPE_TITLE" , 1 )
		work_profile_prompt_details [ next_prompt ,6 ] = 4

		work_profile_propagate [ next_prompt ] = ERROR

		next_prompt = next_prompt + 1

	ENDIF

	work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
	work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
	work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_ANALYSIS_COMPONENT"
	work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_ANAL_COMP_TITLE" , 1 )
	work_profile_prompt_details [ next_prompt ,6 ] = 25

	work_profile_propagate [ next_prompt ] = ERROR

	next_prompt = next_prompt + 1

	IF NOT is_batch THEN

		work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
		work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
		work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_REPEAT"
  		work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_REPEAT_TITLE" , 1 )
		work_profile_prompt_details [ next_prompt ,6 ] = 10

		work_profile_propagate [ next_prompt ] = "work_profile_propagate_repeat"

		next_prompt = next_prompt + 1

	ENDIF

	IF is_batch THEN

		work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
		work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
		work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_OTHER"
		work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_CREATE_TITLE" , 1 )
		work_profile_prompt_details [ next_prompt ,6 ] = 6

		CREATE OBJECT WORK_PROFILE_PROMPT_CONTROL, other

		other . table       = "VERSIONED_C_L_ENTRY"
		other . field       = "CREATE_ALWAYS"
		other . allowed_for =  PROMPT_ON_COMPONENT
	        other . title       = get_user_message ( "WORK_PROFILE_CREATE_TITLE" , 1 )

		work_profile_other_fields [ next_prompt ] = other


		next_prompt = next_prompt + 1

		work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
		work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
		work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_OTHER"
		work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_RES_ENTRY_TITLE" , 1 )
		work_profile_prompt_details [ next_prompt ,6 ] = 9

		CREATE OBJECT WORK_PROFILE_PROMPT_CONTROL, other

		other . table       = "VERSIONED_C_L_ENTRY"
		other . field       = "RESULT_ENTRY"
		other . allowed_for =  PROMPT_ON_COMPONENT
	        other . title       = get_user_message ( "WORK_PROFILE_RES_ENTRY_TITLE" , 1 )

		work_profile_other_fields [ next_prompt ] = other

		next_prompt = next_prompt + 1

	ENDIF

	work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
	work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
	work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_COMPONENT_TYPE"
	work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_COMP_TYPE_TITLE" , 1 )
	work_profile_prompt_details [ next_prompt ,6 ] = 2

	work_profile_propagate [ next_prompt ] = "work_profile_propagate_type"

	next_prompt = next_prompt + 1

	work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
	work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
	work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_DP"
	work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_DP_TITLE" , 1 )
	work_profile_prompt_details [ next_prompt ,6 ] = 4

	work_profile_propagate [ next_prompt ] = "work_profile_propagate_dp"

	next_prompt = next_prompt + 1

	work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
	work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
	work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_LEVEL"
	work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_LEVEL_TITLE" , 1 )
	work_profile_prompt_details [ next_prompt ,6 ] = 10

	work_profile_propagate [ next_prompt ] = ERROR

	next_prompt = next_prompt + 1

	work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
	work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
	work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_LOWER_LIMIT"
	work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_LOWER_TITLE" , 1 )
	work_profile_prompt_details [ next_prompt ,6 ] = 10

	work_profile_propagate [ next_prompt ] = "work_profile_propagate_lower"

	next_prompt = next_prompt + 1

	work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
	work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
	work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_UPPER_LIMIT"
	work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_UPPER_TITLE" , 1 )
	work_profile_prompt_details [ next_prompt ,6 ] = 10

	work_profile_propagate [ next_prompt ] = "work_profile_propagate_upper"

	next_prompt = next_prompt + 1

	work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
	work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
	work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_UNITS"
	work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_UNITS_TITLE" , 1 )
	work_profile_prompt_details [ next_prompt ,6 ] = 10

	work_profile_propagate [ next_prompt ] = "work_profile_propagate_units"

	next_prompt = next_prompt + 1

	work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
	work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
	work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_LIMIT_CALC"
	work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_LIMIT_CALC_TITLE" , 1 )
	work_profile_prompt_details [ next_prompt ,6 ] = 10

	work_profile_propagate [ next_prompt ] = "work_profile_propagate_limit_calc"

	next_prompt = next_prompt + 1

	IF is_batch THEN

		work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
		work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
		work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_SPIKE"
		work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_SPIKE_TITLE" , 1 )
		work_profile_prompt_details [ next_prompt ,6 ] = 10

		CREATE OBJECT WORK_PROFILE_PROMPT_CONTROL, other

		other . table       = "VERSIONED_C_L_ENTRY"
		other . field       = "SPIKE_VALUE"
		other . allowed_for =  PROMPT_ON_COMPONENT
		other . title       = get_user_message ( "WORK_PROFILE_SPIKE_TITLE" , 1 )

 		work_profile_other_fields [ next_prompt ] = other

		next_prompt = next_prompt + 1

	ENDIF

	IF NOT is_batch THEN

		work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
		work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
		work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_IS_STANDARD"
		work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_STANDARD_TITLE" , 1 )
		work_profile_prompt_details [ next_prompt ,6 ] = 10

		work_profile_propagate [ next_prompt ] = "work_profile_propagate_standard"

		next_prompt = next_prompt + 1

	ENDIF

	IF NOT is_batch THEN

		work_profile_prompt_details [ next_prompt ,2 ] = "ROUTINE"
		work_profile_prompt_details [ next_prompt ,3 ] = global ( "current_library" )
		work_profile_prompt_details [ next_prompt ,4 ] = "WORK_PROFILE_OTHER"
		work_profile_prompt_details [ next_prompt ,5 ] = get_user_message ( "WORK_PROFILE_INSTRUMENT_TITLE" , 1 )
		work_profile_prompt_details [ next_prompt ,6 ] = 10

		CREATE OBJECT WORK_PROFILE_PROMPT_CONTROL, other

		other . table       = "TEST_SCHED_ENTRY"
		other . field       = "INSTRUMENT"
		other . allowed_for =  PROMPT_ON_ANALYSIS
 		other . title       = get_user_message ( "WORK_PROFILE_INSTRUMENT_TITLE" , 1 )

		work_profile_other_fields [ next_prompt ] = other

		next_prompt = next_prompt + 1

	ENDIF

	work_profile_user_prompt_details ( is_batch )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_user_prompt_details ( VALUE is_batch )

{
*
*
*******************************************************************************}

	DECLARE user_prompts ,
		count        ,
		other        ,
		position

	ARRAY user_prompts

	IF is_batch THEN

		lab_user_batch_work_profile ( work_profile_prompt_details ,
					      user_prompts                ,
	                                      WORK_PROFILE_PROMPT_CONTROL )

	ELSE

		lab_user_work_profile ( work_profile_prompt_details ,
					user_prompts                ,
	                                WORK_PROFILE_PROMPT_CONTROL )

	ENDIF

	count = 1

	WHILE count <= size_of_array ( user_prompts ) DO

		other    = user_prompts [ count ]
		position = other . position

		array_insert_slice ( work_profile_prompt_details ,
			             1                         	 ,
				     position                    )

		work_profile_prompt_details [ position ,2 ] = "ROUTINE"
		work_profile_prompt_details [ position ,3 ] = global ( "current_library" )
		work_profile_prompt_details [ position ,4 ] = "WORK_PROFILE_OTHER"
		work_profile_prompt_details [ position ,5 ] = other . title
		work_profile_prompt_details [ position ,6 ] = other . width

		array_insert_slice ( work_profile_other_fields ,
			             1                         ,
				     position                  )

		work_profile_other_fields [ position ] = other

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_got_data ( entries )

{
*
*
*******************************************************************************}

	DECLARE got_data

	got_data = FALSE

	IF variable_is_assigned ( entries ) THEN

		IF entries <> EMPTY THEN

			got_data = TRUE

		ENDIF

	ENDIF

	RETURN ( got_data )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_class_initialisation ( self )

{
*
*
*******************************************************************************}

	self . analysis         = ""
	self . schedule         = ""
	self . component_list   = ""
	self . component        = ""
	self . replicates       = 0
	self . level            = ""
	self . limits           = EMPTY
	self . dp               = 0
	self . units            = ""
	self . entry_code       = 0
	self . component_type   = ""
	self . textual_value    = ""
	self . comparison       = "P"
	self . is_standard      = TRUE

	ARRAY self . other_fields ARRAY_SIZE ( 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_action_is_analysis ( self )

{
*
*
*******************************************************************************}

	DECLARE is_analysis

	is_analysis = NOT blank ( self . analysis  ) AND
			  blank ( self . schedule  ) AND
			  blank ( self . component ) AND
			  blank ( self . level     )

	RETURN ( is_analysis )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_action_is_schedule ( self )

{
*
*
*******************************************************************************}

	DECLARE is_schedule

	is_schedule = NOT blank ( self . schedule  )

	RETURN ( is_schedule )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_action_is_component ( self )

{
*
*
*******************************************************************************}

	DECLARE is_component

	is_component = NOT blank ( self . analysis  ) AND
		       NOT blank ( self . component ) AND
		           blank ( self . schedule  )

	RETURN ( is_component )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_action_is_level ( self )

{
*
*
*******************************************************************************}

	DECLARE is_level

	is_level =     blank ( self . analysis  ) AND
		       blank ( self . component ) AND
		       blank ( self . schedule  ) AND
		   NOT blank ( self . level     )

	RETURN ( is_level )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_action_is_textual ( self )

{
*
*
*******************************************************************************}

	DECLARE is_text_comparison

	is_text_comparison =     blank ( self . analysis             ) AND
			         blank ( self . component            ) AND
			         blank ( self . level                ) AND
				 blank ( self . schedule             ) AND
				       ( self . component_type = "T" ) AND
			     NOT blank ( self . textual_value        )

	RETURN ( is_text_comparison )

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_entry_action_is_type (       self          ,
					   VALUE required_type )

{
*
*
*******************************************************************************}

	RETURN ( self . component_type = required_type )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_analysis ( entry )

{
*
*
*******************************************************************************}

	RETURN ( entry . is_analysis ( ))

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_schedule ( entry )

{
*
*
*******************************************************************************}

	RETURN ( entry . is_schedule ( ))

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_component ( entry )

{
*
*
*******************************************************************************}

	RETURN ( entry . is_component ( ))

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_level ( entry )

{
*
*
*******************************************************************************}

	RETURN ( entry . is_level ( ))

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_text_comparison ( entry )

{
*
*
*******************************************************************************}

	RETURN ( entry . is_textual ( ))

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_lock_analysis ( VALUE analysis         ,
                                     VALUE analysis_version ,
                                     VALUE mode             ,
                                           all_locked       )

{
*
*
*******************************************************************************}

	DECLARE is_locked   ,
		identity    ,
		message_ptr

	IF mode <> "DISPLAY" THEN

		SET GLOBAL "lock_screen" TO FALSE

		identity = SELECT versioned_analysis . identity
			   FOR UPDATE
			   WHERE ( identity         = analysis         ) AND
				 ( analysis_version = analysis_version )

		SET GLOBAL "lock_screen" TO TRUE

		is_locked = identity <> locked

		IF NOT is_locked THEN

			message_fetch ( "WORK_PROFILE_ANAL_LOCK" ,
					 message_ptr             )

			message_add_parameter ( message_ptr      ,
						strip ( analysis ))

			flash_message ( message_get_text ( message_ptr , 1 ),
					TRUE                                )

		ENDIF

	ELSE

		is_locked = TRUE

	ENDIF

	IF NOT is_locked THEN

		all_locked = FALSE

	ENDIF

	RETURN ( is_locked )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_lock_limit_phrase ( VALUE limit_phrase ,
				         VALUE mode         ,
				               all_locked   )

{
*
*
*******************************************************************************}

	DECLARE is_locked   ,
		identity

	IF mode <> "DISPLAY" THEN

		identity = SELECT limit_phrase_header . identity
			   FOR UPDATE
			   WHERE identity = limit_phrase

		is_locked = identity <> locked

	ELSE

		is_locked = TRUE

	ENDIF

	IF NOT is_locked THEN

		all_locked = FALSE

	ENDIF

	RETURN ( is_locked )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_analysis_for_entry ( VALUE row     ,
                                                entries )

{
*
*
*******************************************************************************}

	DECLARE count    ,
		analysis

	count = row

        WHILE ( count <> 0                                       ) AND
	      ( NOT work_profile_is_analysis ( entries [ count ] )) DO

		count = count - 1

	ENDWHILE

	IF count > 0 THEN

		analysis = entries [ count ] . analysis

	ELSE

		analysis = ""

	ENDIF

	RETURN ( analysis )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_action_read_others (       self  ,
					       VALUE table )

{
*
*
*******************************************************************************}

	DECLARE count ,
		other

	count = 1

	WHILE count <= size_of_array ( work_profile_other_fields ) DO

		other = work_profile_other_fields [ count ]

		IF other <> EMPTY THEN

			IF other . table = table THEN

				self . other_fields [ count ] =
					SELECT 'table' . 'other . field'

			ENDIF

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_setup_component_fields ( VALUE analysis   ,
					      VALUE component  ,
					      VALUE level      ,
					      VALUE entry_code ,
					      VALUE mode       ,
						    new_entry  ,
						    phrase_id  )

{
*
*
*******************************************************************************}

	DECLARE result_type        ,
		selected_component

	selected_component = SELECT component . name

	IF (        selected_component   <> component ) OR
	   ( SELECT component . analysis <> analysis  ) THEN

		selected_component = SELECT component . name
				     WHERE ( name     = component ) AND
					   ( analysis = analysis  )

	ENDIF

	new_entry . component_order = SELECT component . order_number

	new_entry . level      = level

	IF new_entry . replicates = 0 THEN

		new_entry . replicates = 1

	ENDIF

	result_type = SELECT component . result_type

	IF ( result_type = "N" ) OR
	   ( result_type = "L" ) OR
           ( result_type = "K" ) THEN

		new_entry . component_type = "N"

	ELSEIF ( result_type = "B" ) THEN

		new_entry . component_type = "B"

	ELSEIF ( result_type = "I" ) THEN

		new_entry . component_type = "I"

	ELSE

		new_entry . component_type = "T"

	ENDIF

	new_entry . dp         = SELECT component . places
	new_entry . units      = SELECT component . units
	new_entry . entry_code = entry_code

	IF mode <> "DISPLAY" THEN

		new_entry . limits = limit_mod_find_limit ( "MODIFY"                   ,
						            level                      ,
							    entry_code                 ,
							    EMPTY                      ,
							    new_entry . component_type ,
							    new_entry . dp             ,
							    new_entry . units          )


		IF lib_comp_has_category ( component        ,
				           CATEGORY_BLANK   ) THEN

			ASSIGN limit .calculation IN OBJECT new_entry . limits =
					"PASSBLANK"

		ENDIF

	ELSE

		new_entry . limits = EMPTY


	ENDIF

	IF SELECT component . result_type = "O" THEN

		phrase_id = SELECT component . calculation

	ELSE

		phrase_id = ""

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_analysis_version ( VALUE analysis         ,
                                              analysis_version )

{
*
*	Find the highest analysis version or die
*
{******************************************************************************}

	DECLARE error_message, ret_value

	analysis_version = SELECT analysis . analysis_version
			    WHERE identity = analysis

	IF ( analysis_version = EMPTY ) OR ( analysis_version = ERROR ) THEN

		message_fetch ( "WORK_PROFILE_NO_ANALYSIS", error_message )
		message_add_parameter ( error_message, strip ( analysis ))

		flash_message ( message_get_text ( error_message, 1 ), true )
		ret_value = FALSE

	ELSE

		ret_value = TRUE

	ENDIF

	RETURN ( ret_value )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_mlp_version_no_message ( VALUE product         ,
                                                    product_version )

{
*
*	Find the highest mlp version quietly
*
{******************************************************************************}

	product_version = SELECT MAX mlp_versions . product_version
	                         WHERE identity = product

	RETURN (( product_version <> EMPTY ) AND ( product_version <> ERROR ))

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_mlp_version ( VALUE product         ,
                                         product_version )

{
*
*	Find the highest mlp version or die
*
{******************************************************************************}

	DECLARE error_message, ret_value

	IF NOT work_profile_mlp_version_no_message ( product         ,
                                                     product_version ) THEN

		message_fetch ( "WORK_PROFILE_NO_PRODUCT", error_message )
		message_add_parameter ( error_message, strip ( product ))

		flash_message ( message_get_text ( error_message, 1 ), true )
		ret_value = FALSE

	ELSE

		ret_value = TRUE

	ENDIF

	RETURN ( ret_value )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_setup_batch_schedule ( VALUE spec_header ,
			            	    VALUE mode        ,
				                  entries     )
{
*
*
*******************************************************************************}

	DECLARE new_entry

	CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

	new_entry . analysis         = SELECT batch_tmpl_header . analysis
	new_entry . replicates       = 1
	new_entry . component_list   = spec_header

	work_profile_analysis_version ( new_entry . analysis         ,
                                        new_entry . analysis_version )

	entries [ 1 ] = new_entry

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_setup_batch_components ( VALUE spec_header ,
			            	      VALUE mode        ,
				                    entries     ,
						    levels      )
{
*
*
*******************************************************************************}

	DECLARE grid     ,
		analysis

	grid = EMPTY

	IF size_of_array ( entries ) = 1 THEN

		analysis = SELECT batch_tmpl_header . analysis

		work_profile_insert_all_components ( analysis ,
						     ""       ,
						     TRUE     ,
						     TRUE     ,
						     entries  ,
						     levels   ,
						     grid     ,
						     2        )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_read_test_schedule ( VALUE spec_header ,
			            	  VALUE mode        ,
				                entries     ,
					        all_locked  )

{
*
*
*******************************************************************************}

	DECLARE analysis        ,
		count           ,
		new_entry       ,
		test_schedule   ,
		file_descriptor ,
	        add_record

	IF mode = "COPY" THEN

		push_file_descriptor ( "MLP_HEADER"  , file_descriptor )

		test_schedule = SELECT mlp_header . test_schedule
			        WHERE  identity = spec_header
			        ORDER ON product_version DESCENDING

		pop_file_descriptor ( file_descriptor )

	ELSE

		test_schedule = SELECT mlp_header . test_schedule

	ENDIF


	count    = 1

	analysis = SELECT test_sched_entry . analysis_id
		   WHERE  identity = test_schedule
		   ORDER ON order_num

	WHILE analysis <> EMPTY DO

		add_record = TRUE

		CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

		IF SELECT test_sched_entry . is_analysis THEN

			new_entry . analysis         = SELECT test_sched_entry . analysis_id
			new_entry . replicates       = SELECT test_sched_entry . replicate_count
			new_entry . component_list   = SELECT test_sched_entry . component_list

			IF work_profile_analysis_version (
			                 new_entry . analysis         ,
			                 new_entry . analysis_version ) THEN

				work_profile_lock_analysis
			                     ( new_entry . analysis         ,
			                       new_entry . analysis_version ,
			                       mode                         ,
			                       all_locked                   )

			ELSE

				add_record = FALSE

			ENDIF

		ELSE

			new_entry . schedule   = SELECT test_sched_entry . analysis_id

		ENDIF

		IF add_record THEN

			new_entry . is_standard = SELECT test_sched_entry .
			                                 std_test

			new_entry . read_others ( "TEST_SCHED_ENTRY" )

			entries [ count ] = new_entry

			count = count + 1

		ENDIF

		NEXT test_sched_entry

		analysis = SELECT test_sched_entry . analysis_id

	ENDWHILE

	RETURN ( all_locked )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_read_a_component ( VALUE analysis         ,
				        VALUE analysis_version ,
				        VALUE component        ,
					      levels           ,
					      entries          ,
					      position         )

{
*
*
*******************************************************************************}

	DECLARE new_entry ,
		count

	count = 1

	WHILE count <= size_of_array ( levels ) DO

		CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

		IF count = 1 THEN

			new_entry . analysis         = analysis
			new_entry . analysis_version = analysis_version
			new_entry . component        = component

			new_entry . replicates = SELECT versioned_c_l_entry . replicate_count
			new_entry . read_others ( "VERSIONED_C_L_ENTRY" )

		ENDIF

		new_entry . component_order  =
				SELECT versioned_c_l_entry . order_number

		new_entry . actual_analysis  = analysis
		new_entry . actual_component = component
		new_entry . level            = levels [ count ]

		array_insert_slice ( entries  ,
				     1        ,
				     position )

		entries [ position ] = new_entry

		position = position + 1
		count    = count    + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_read_component_lists ( VALUE spec_header ,
					    VALUE mode        ,
						  levels      ,
						  entries     )

{
*
*
*******************************************************************************}

	DECLARE count            ,
		component        ,
		analysis         ,
		analysis_version ,
		list

	count = 1

	WHILE count <= size_of_array ( entries ) DO

		analysis         = entries [ count ] . analysis

		IF NOT blank ( analysis ) THEN

			analysis_version = entries [ count ] . analysis_version
			list             = entries [ count ] . component_list

			IF mode = "COPY" THEN

				entries [ count ] . component_list = ""

			ENDIF

			count = count + 1

			component = SELECT versioned_c_l_entry . name
				    WHERE ( analysis         = analysis          ) AND
					  ( analysis_version = analysis_version  ) AND
					  ( comp_list        = list              )
				    ORDER ON order_number

			WHILE component <> EMPTY DO

				work_profile_read_a_component ( analysis         ,
							        analysis_version ,
							        component        ,
							        levels           ,
							        entries          ,
						        	count            )

    				NEXT versioned_c_l_entry

				component = SELECT versioned_c_l_entry . name

			ENDWHILE

		ELSE

			count = count + 1

		ENDIF

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_read_mlp_levels ( VALUE spec_header ,
				       VALUE mode        ,
					     entry_code  ,
					     levels      )

{
*
*
*******************************************************************************}

	DECLARE copy_entry_code, file_descriptor, continue
	continue = TRUE

	IF mode = "COPY" THEN

		entry_code = level_get_entry_code ()

		push_file_descriptor ( "MLP_HEADER", file_descriptor )

		copy_entry_code = SELECT mlp_header . entry_code
			          WHERE  identity = spec_header
			          ORDER ON product_version DESCENDING

		pop_file_descriptor ( file_descriptor )

		IF copy_entry_code <> EMPTY THEN

			level_mod_copy ( entry_code      ,
					 copy_entry_code )

		ENDIF

	ELSE

		entry_code = SELECT mlp_header . entry_code

		IF entry_code = 0 THEN

			entry_code = level_get_entry_code ()

		ENDIF

	ENDIF

	level_mod_active_level_list ( mode       ,
				      entry_code ,
			              levels     )

	continue = ( SIZE_OF_ARRAY ( levels ) <> 0 )

	IF ( mode = "MODIFY" ) AND ( NOT continue ) THEN

		level_mod_screen ( mode       ,
				   entry_code )

		level_mod_active_level_list ( mode       ,
					      entry_code ,
		        		      levels     )

		continue = ( SIZE_OF_ARRAY ( levels ) <> 0 )

	ENDIF

	RETURN ( continue )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_read_limit_phrase ( VALUE mode       ,
					      entries    ,
					      position   ,
					      limit      ,
					      all_locked )
{
*
*
*******************************************************************************}

	DECLARE limit_phrase  ,
	        compare_value ,
	        first_time    ,
	        entry	      ,
	        analysis      ,
	        component

	first_time = TRUE

	limit_phrase = SELECT limit . text_phrase IN OBJECT limit

	IF NOT blank ( limit_phrase ) THEN

		work_profile_lock_limit_phrase ( limit_phrase ,
						mode         ,
						all_locked   )

		compare_value = SELECT limit_phrase_entry . result_value
				WHERE  limit_phrase = limit_phrase
				ORDER ON order_number

		WHILE compare_value <> EMPTY DO

			IF first_time THEN

				entry = entries [ position ]
				analysis  = entry . analysis
				component = entry . component
				first_time = FALSE

			ELSE

				position = position + 1

				CREATE OBJECT WORK_PROFILE_ENTRY, entry

				entry . component_type   = "T"
				entry . actual_analysis  = analysis
				entry . actual_component = component

				array_insert_slice ( entries  ,
						     1        ,
						     position )

				entries [ position ] = entry

			ENDIF

			entry . textual_value = compare_value
			entry . comparison    = SELECT limit_phrase_entry . comparison

			NEXT limit_phrase_entry

			compare_value = SELECT limit_phrase_entry . result_value

		ENDWHILE

		IF mode = "COPY" THEN

			ASSIGN limit . text_phrase IN OBJECT limit = ""

		ENDIF

	ELSE

		entry                 = entries [ position ]
		entry . textual_value = SELECT limit . text_spec IN OBJECT limit
		entry . comparison    = "P"


	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_read_mlp_limits ( VALUE entry_code ,
				       VALUE copy_entry ,
			               VALUE mode       ,
					     levels     ,
				             entries    ,
				             position   ,
					     all_locked )

{
*
*
*******************************************************************************}

	DECLARE count      ,
		level_name ,
		limit

	count = 1

	WHILE count <= size_of_array ( levels ) DO

		level_name = levels [ count ]

		entries [ position ] . dp    = SELECT mlp_components . places
		entries [ position ] . units = SELECT mlp_components . units
		entries [ position ] . component_type =
				SELECT mlp_components . component_type
		entries [ position ] . entry_code     = entry_code

		limit = limit_mod_find_limit ( mode                             ,
				               level_name                       ,
				               entry_code                       ,
				               copy_entry                           ,
			     	               SELECT mlp_components .component_type ,
				               SELECT mlp_components . places   ,
				               SELECT mlp_components . units    )

		entries [ position ] . level  = level_name
		entries [ position ] . limits = limit

		IF entries [ position ] . is_type ( "T" ) THEN

			work_profile_read_limit_phrase ( mode       ,
							entries    ,
							position   ,
							limit      ,
							all_locked )

		ENDIF

		count    = count + 1
		position = position + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_setup_phrase (       entry     ,
				   VALUE phrase_id ,
		                         entries   ,
				         position  )

{
*
*
*******************************************************************************}

	DECLARE new_entry

	phrase_id = SELECT phrase . phrase_text
		    WHERE  ( phrase_type = phrase_id ) AND
	                   ( phrase_text <> " "      )
        	    ORDER ON order_num

	IF phrase_id <> EMPTY THEN

		entry . textual_value = phrase_id

	ENDIF


	NEXT phrase
	phrase_id = SELECT phrase . phrase_text

	WHILE phrase_id <> EMPTY DO

		position = position + 1

		CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

		new_entry . component_type   = "T"
		new_entry . textual_value    = phrase_id
		new_entry . actual_analysis  = entry . analysis
		new_entry . actual_component = entry . component

		array_insert_slice ( entries  ,
				     1        ,
				     position )

		entries [ position ] = new_entry

		NEXT phrase
		phrase_id = SELECT phrase . phrase_text


	ENDWHILE

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_setup_mlp_limits ( VALUE analysis   ,
				        VALUE component  ,
				        VALUE mode       ,
					VALUE entry_code ,
					      levels     ,
				              entries    ,
				              position   )


{
*
*
*******************************************************************************}

	DECLARE count      ,
		level_name ,
		phrase_id

	IF entry_code = EMPTY THEN

		IF mode <> "DISPLAY" THEN

			entry_code = limit_get_entry_code ()

		ELSE

			entry_code = 0

		ENDIF

	ENDIF

	count = 1

	WHILE count <= size_of_array ( levels ) DO

		level_name = levels [ count ]
		entries [ position ] . entry_code     = entry_code

		work_profile_setup_component_fields ( analysis             ,
						     component            ,
						     level_name           ,
						     entry_code           ,
						     mode                 ,
						     entries [ position ] ,
						     phrase_id            )

		IF NOT blank ( phrase_id ) THEN

			work_profile_setup_phrase ( entries [ position ] ,
				   		   phrase_id            ,
		                                   entries              ,
				                   position             )

		ENDIF

		count    = count + 1
		position = position + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_read_mlp_component ( VALUE spec_header ,
					 VALUE mlp_version ,
			                 VALUE mode        ,
					       levels      ,
				               entries     ,
					       all_locked  )

{
*
*
*******************************************************************************}

	DECLARE count      ,
		component  ,
		analysis   ,
		entry_code ,
		copy_entry ,
		found

	count = 1

	WHILE count <= size_of_array ( entries ) DO

		analysis  = entries [ count ] . analysis
		component = entries [ count ] . component

		IF NOT blank ( component ) THEN

			entry_code = SELECT mlp_components . entry_code
			             WHERE ( product_id      = spec_header ) AND
				           ( product_version = mlp_version ) AND
				           ( analysis_id     = analysis    ) AND
		    			   ( component_name  = component   )

			found = entry_code <> EMPTY

			IF mode = "COPY" THEN

				copy_entry = entry_code
				entry_code = limit_get_entry_code ()

			ELSE

				copy_entry = EMPTY

			ENDIF

			IF found THEN

				work_profile_read_mlp_limits ( entry_code ,
							       copy_entry ,
							       mode       ,
							       levels     ,
							       entries    ,
							       count      ,
							       all_locked )

			ELSE

				work_profile_setup_mlp_limits ( analysis  ,
							        component ,
							        mode      ,
								EMPTY     ,
							        levels    ,
							        entries   ,
							        count     )

			ENDIF

		ELSE

			count = count + 1

		ENDIF

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_add_insert_line ( VALUE mode    ,
				            entries )

{
*
*
*******************************************************************************}

	DECLARE entry    ,
		position

	CREATE OBJECT WORK_PROFILE_ENTRY, entry
	entry . replicates = 0

	position = size_of_array ( entries ) + 1

	entries [ position ] = entry

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_read_data ( VALUE spec_header      ,
				 VALUE mlp_version      ,
				 VALUE mode             ,
				 VALUE is_batch         ,
				       entries          ,
				       level_entry_code ,
				       levels           ,
				       all_locked       )

{
*
*
*******************************************************************************}

	DECLARE continue
	continue = FALSE

 	ARRAY entries ARRAY_SIZE ( 0 )
	ARRAY levels  ARRAY_SIZE ( 0 )

	all_locked = TRUE

	IF is_batch THEN

		work_profile_setup_batch_schedule ( spec_header ,
					            mode        ,
					            entries     )

	ELSE

		work_profile_read_test_schedule ( spec_header ,
						  mode        ,
						  entries     ,
						  all_locked  )

	ENDIF

	IF work_profile_read_mlp_levels ( spec_header      ,
	  			          mode             ,
				          level_entry_code ,
				          levels           ) THEN

		continue = TRUE

		work_profile_read_component_lists ( spec_header ,
						    mode        ,
						    levels      ,
						    entries     )

		work_profile_read_mlp_component  ( spec_header ,
						   mlp_version ,
						   mode        ,
						   levels      ,
						   entries     ,
						   all_locked  )

		IF ( is_batch )

			work_profile_setup_batch_components ( spec_header ,
						              mode        ,
						              entries     ,
							      levels      )

		ENDIF

		work_profile_add_insert_line ( mode    ,
					       entries )

	ENDIF

	RETURN ( continue )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_spec_header_to_test_sched ( VALUE spec_header )

{
*
*
*******************************************************************************}

DECLARE size

	GET_FIELD_DETAILS mlp_header . identity
		         "FIELD_SIZE"    ,
			  size

	RETURN ( substring ( spec_header, 1, size ))

ENDROUTINE

{******************************************************************************}
{******************************************************************************}
{******************************************************************************}
{******************************************************************************}

GLOBAL ROUTINE work_profile_change_analysis ( VALUE new_analysis ,
					      VALUE old_analysis )

{
*       Called from batch code when analysis changes.
*
*******************************************************************************}

	DECLARE count       ,
		delete_slot ,
		add         ,
		delete_it   ,
		spec_header ,
		size        ,
		mode        ,
		mlp_version


	spec_header = SELECT batch_tmpl_header . identity

	GET_FIELD_DETAILS mlp_header . identity
		         "FIELD_SIZE"    ,
			  size

	spec_header = pad ( spec_header , " " , size )

	mode = "MODIFY"

	IF NOT work_profile_got_data ( work_profile_entries ) THEN

		work_profile_initialise ( TRUE )

		IF work_profile_mlp_version_no_message ( spec_header,
		                                         mlp_version ) THEN

			work_profile_read_data (  spec_header                   ,
						  mlp_version                   ,
						 "MODIFY"                       ,
						  TRUE                          ,
						  work_profile_entries          ,
						  work_profile_level_entry_code ,
						  work_profile_levels           ,
						  work_profile_all_locked       )

		ENDIF

	ELSE

		ARRAY work_profile_entries

		work_profile_setup_batch_schedule ( spec_header          ,
					            mode                 ,
					            work_profile_entries )

		work_profile_setup_batch_components ( spec_header          ,
					              mode                 ,
					              work_profile_entries ,
					              work_profile_levels  )

	ENDIF

	delete_slot = 0
	add         = TRUE

	count = 1

	WHILE count <= size_of_array ( work_profile_deleted_analyses ) DO

		IF work_profile_deleted_analyses [ count ] . analysis = new_analysis THEN

			delete_slot = count

		ELSEIF work_profile_deleted_analyses [ count ] . analysis = old_analysis THEN

			add = FALSE

			RETURN

		ENDIF

		count = count + 1

	ENDWHILE

	IF ( add                       )  AND
	   ( NOT blank ( old_analysis )) THEN

		CREATE OBJECT work_profile_analysis , delete_it

		delete_it . analysis = old_analysis

		IF work_profile_analysis_version (
		                delete_it . analysis         ,
		                delete_it . analysis_version ) THEN

			work_profile_deleted_analyses [ count ] = delete_it

		ENDIF

	ENDIF

	IF delete_slot <> 0 THEN

		array_remove_slice ( work_profile_deleted_analyses ,
				     1                             ,
				     delete_slot                   )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_analysis_active ( VALUE analysis        ,
					    active_analyses )

{
*
*
*******************************************************************************}

	DECLARE count

	count = 1

	WHILE count <= size_of_array ( active_analyses ) DO

		IF active_analyses [ count ] . analysis = analysis THEN

			RETURN ( count )

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_schedule_active ( VALUE schedule  ,
					    schedules )

{
*
*
*******************************************************************************}

	DECLARE count

	count      = 1

	WHILE count <= size_of_array ( schedules ) DO

		IF schedules [ count ] . schedule = schedule THEN

			RETURN ( count )

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_build_analysis_array ( VALUE spec_header     ,
						 entries         ,
					         active_analyses )

{
*
*
*******************************************************************************}

	DECLARE count        ,
		entry        ,
		new_entry    ,
		position     ,
		order_number

	ARRAY active_analyses ARRAY_SIZE ( 0 )

	position     = 1
	count        = 1
	order_number = 1

	WHILE count <= size_of_array ( entries ) DO

		entry = entries [ count ]

		IF work_profile_is_analysis ( entry ) THEN

			CREATE OBJECT WORK_PROFILE_ANALYSIS, new_entry

			new_entry . analysis         = entry . analysis
			new_entry . analysis_version = entry . analysis_version
			new_entry . component_list   = entry . component_list

			IF blank ( new_entry . component_list ) THEN

				new_entry . component_list = spec_header

			ENDIF

			new_entry . position       = count
			new_entry . not_updated    = TRUE
			new_entry . order_number   = order_number

			active_analyses [ position ] = new_entry

			position     = position + 1
			order_number = order_number + 1

		ELSEIF work_profile_is_schedule ( entry ) THEN

			order_number = order_number + 1

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_build_schedule_array ( entries   ,
					   schedules )

{
*
*
*******************************************************************************}

	DECLARE count        ,
		entry        ,
		new_entry    ,
		position     ,
		order_number

	ARRAY schedules ARRAY_SIZE ( 0 )

	position     = 1
	count        = 1
	order_number = 1

	WHILE count <= size_of_array ( entries ) DO

		entry = entries [ count ]

		IF work_profile_is_schedule ( entry ) THEN


			CREATE OBJECT WORK_PROFILE_SCHEDULE, new_entry

			new_entry . schedule     = entry . schedule
			new_entry . not_updated  = TRUE
			new_entry . order_number = order_number
			new_entry . replicates   = entry . replicates

			schedules [ position ] = new_entry

			position     = position + 1
			order_number = order_number + 1

		ELSEIF work_profile_is_analysis ( entry ) THEN

			order_number = order_number + 1

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_build_components ( VALUE analysis         ,
				              entries          ,
				              components       )

{
*
*
*******************************************************************************}

	DECLARE count        ,
		new_entry    ,
		position

	ARRAY components ARRAY_SIZE ( 0 )

	position = 1
	count    = 1

	WHILE count <= size_of_array ( entries ) DO

		IF ( entries [ count ] . analysis = analysis     ) AND
		   ( work_profile_is_component ( entries [ count ] )) THEN

			CREATE OBJECT WORK_PROFILE_COMPONENT, new_entry

			new_entry . component    = entries [ count ] . component
			new_entry . position     = count
			new_entry . not_updated  = TRUE
			new_entry . order_number = count

			components [ position ] = new_entry

			position = position + 1

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_find_analysis_component ( VALUE analysis   ,
				               VALUE name       ,
				                     components )

{
*
*
*******************************************************************************}

	DECLARE count

	count = 1

	WHILE count <= size_of_array ( components ) DO

		IF components [ count ] . component = name THEN

			RETURN ( count )

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( EMPTY )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_action_write_others (       self  ,
					         VALUE table )

{
*
*
*******************************************************************************}

	DECLARE count ,
		other

	count = 1

	WHILE count <= size_of_array ( work_profile_other_fields ) DO

		other = work_profile_other_fields [ count ]

		IF other <> EMPTY THEN

			IF other . table = table THEN

				IF self . other_fields [ count ] <> EMPTY THEN

					ASSIGN 'table' . 'other . field' =
						self . other_fields [ count ]

				ENDIF

			ENDIF

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_test_sched_header ( VALUE spec_header )

{
*
*
*******************************************************************************}

	DECLARE temp

	spec_header = work_profile_spec_header_to_test_sched ( spec_header )

	temp = SELECT test_sched_header . identity
	       FOR UPDATE
	       WHERE identity = spec_header

	IF temp = EMPTY THEN

		RESERVE ENTRY test_sched_header , spec_header

	ENDIF

	ASSIGN test_sched_header . modified_on = now
	ASSIGN test_sched_header . modified_by = operator
	ASSIGN test_sched_header . description = SELECT mlp_header . description
	ASSIGN test_sched_header . group_id    = SELECT mlp_header . group_id

	UPDATE test_sched_header

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_test_sched_entry_analysis ( VALUE position        ,
                                                        VALUE spec_header     ,
                                                              active_analyses ,
                                                              entries         )

{
*
*
*******************************************************************************}

	DECLARE entry      ,
		analysis

	analysis = active_analyses [ position ]
	analysis . not_updated = FALSE

	entry    = entries [ analysis . position ]

	ASSIGN test_sched_entry . std_test        = entry . is_standard
	ASSIGN test_sched_entry . is_analysis     = TRUE
	ASSIGN test_sched_entry . replicate_count = entry . replicates
	ASSIGN test_sched_entry . component_list  = analysis . component_list

	entry . write_others ( "TEST_SCHED_ENTRY" )

	UPDATE test_sched_entry


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_test_sched_entry_schedule ( VALUE position  ,
                                                              schedules )

{
*
*
*******************************************************************************}

	DECLARE schedule

	schedule = schedules [ position ]
	schedule . not_updated = FALSE

	ASSIGN test_sched_entry . std_test        = TRUE
	ASSIGN test_sched_entry . replicate_count = 1
	ASSIGN test_sched_entry . is_analysis     = FALSE

	UPDATE test_sched_entry

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_test_sched_entry_update ( VALUE spec_header      ,
					                    entries          ,
						            active_analyses  ,
					                    schedules        )
{
*
*
*******************************************************************************}

	DECLARE position          ,
		existing_analysis

	existing_analysis = SELECT test_sched_entry . analysis_id
			    FOR UPDATE
			    WHERE  identity = spec_header
			    ORDER ON order_num

	WHILE existing_analysis <> EMPTY DO

		IF SELECT test_sched_entry . is_analysis THEN

			position = work_profile_analysis_active ( existing_analysis ,
			                                          active_analyses   )

		ELSE

			position = work_profile_schedule_active ( existing_analysis ,
			                                          schedules         )

		ENDIF

		IF position = 0 THEN

			DELETE test_sched_entry

		ELSEIF SELECT test_sched_entry . is_analysis THEN

			IF active_analyses [ position ] . order_number <>
			   ( SELECT test_sched_entry . order_num ) THEN

				{ Its moved - delete it and add it at its new position }

				DELETE test_sched_entry

				active_analyses [ position ] . not_updated = TRUE

			ELSE

				work_profile_update_test_sched_entry_analysis
				                            ( position        ,
				                              spec_header     ,
				                              active_analyses ,
				                              entries         )

			ENDIF

		ELSE

			IF schedules [ position ] . order_number <>
			   ( SELECT test_sched_entry . order_num ) THEN

				{ Its moved - delete it and add it at its new position }

				DELETE test_sched_entry

				schedules [ position ] . not_updated = TRUE

			ELSE

				work_profile_update_test_sched_entry_schedule ( position  ,
				                                                schedules )

			ENDIF

		ENDIF

		NEXT test_sched_entry

		existing_analysis = SELECT test_sched_entry . analysis_id

	ENDWHILE

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_update_test_sched_entry_insert_analyses ( VALUE spec_header     ,
                                                                     entries         ,
                                                                     active_analyses )

{
*
*
*******************************************************************************}

	DECLARE position

	position = 1

	WHILE position <= size_of_array ( active_analyses ) DO

		IF active_analyses [ position ] . not_updated THEN

			RESERVE ENTRY test_sched_entry ,
			              spec_header :
			              active_analyses [ position ] . analysis :
			              active_analyses [ position ] . order_number

			work_profile_update_test_sched_entry_analysis
			                                    ( position        ,
			                                      spec_header     ,
			                                      active_analyses ,
			                                      entries         )

		ENDIF

		position = position + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_test_sched_entry_insert_schedules ( VALUE spec_header      ,
					                             entries          ,
						                     schedules  )
{
*
*
*******************************************************************************}

	DECLARE position

	position = 1

	WHILE position <= size_of_array ( schedules ) DO

		IF schedules [ position ] . not_updated THEN

			RESERVE ENTRY test_sched_entry ,
			              spec_header :
			              schedules [ position ] . schedule :
			              schedules [ position ] . order_number

			work_profile_update_test_sched_entry_schedule ( position  ,
			                                                schedules )

		ENDIF

		position = position + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_test_schedule ( VALUE spec_header      ,
					          entries          ,
						  active_analyses  ,
					          deleted_analyses )
{
*
*
*******************************************************************************}

	DECLARE schedules     ,
		test_schedule

	test_schedule = SELECT mlp_header . test_schedule

	work_profile_build_schedule_array ( entries   ,
					    schedules )

	work_profile_update_test_sched_header ( spec_header )

	work_profile_update_test_sched_entry_update ( test_schedule   ,
						      entries         ,
						      active_analyses ,
						      schedules       )

	work_profile_update_test_sched_entry_insert_analyses ( test_schedule   ,
						              entries         ,
						              active_analyses )

	work_profile_update_test_sched_entry_insert_schedules ( test_schedule ,
						               entries       ,
						               schedules     )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_a_component_list ( VALUE spec_header      ,
					       VALUE analysis         ,
					       VALUE analysis_version )

{
*
*
*******************************************************************************}

	DECLARE temp

	temp = SELECT versioned_c_l_header . analysis
	       FOR UPDATE
	       WHERE ( analysis         = analysis            ) AND
		     ( analysis_version = analysis_version    ) AND
		     ( comp_list        = spec_header         )

	IF temp <> EMPTY THEN

		DELETE versioned_c_l_header

	ENDIF

	temp = SELECT versioned_c_l_entry . analysis
	       FOR UPDATE
	       WHERE ( analysis         = analysis            ) AND
		     ( analysis_version = analysis_version    ) AND
		     ( comp_list        = spec_header         )

	WHILE temp <> EMPTY DO

		DELETE versioned_c_l_entry

		NEXT versioned_c_l_entry

		temp = SELECT versioned_c_l_entry . analysis

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_component_list_header ( VALUE component_list   ,
						    VALUE analysis         ,
						    VALUE analysis_version )

{
*
*
*******************************************************************************}

	DECLARE temp

	temp = SELECT versioned_c_l_header . analysis
	       FOR UPDATE
	       WHERE ( analysis         = analysis            ) AND
		     ( analysis_version = analysis_version    ) AND
		     ( comp_list        = component_list      )

	IF temp = EMPTY THEN

		RESERVE ENTRY versioned_c_l_header ,
			      analysis             :
			      analysis_version     :
			      component_list

	ENDIF

	ASSIGN versioned_c_l_header . description =
			SELECT  mlp_header . description

	UPDATE versioned_c_l_header

	temp = SELECT versioned_analysis . identity
	       FOR UPDATE
	       WHERE  ( identity         = analysis         ) AND
	              ( analysis_version = analysis_version )

	IF temp = analysis THEN

		ASSIGN versioned_analysis . modified_on = now
		ASSIGN versioned_analysis . modified_by = operator

		UPDATE versioned_analysis

        ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_component_list_entries ( VALUE spec_header      ,
						     VALUE component_list   ,
						     VALUE analysis         ,
						     VALUE analysis_version ,
						           entries          )

{
*
*
*******************************************************************************}

	DECLARE name       ,
		position   ,
		components ,
		component  ,
		entry

	work_profile_build_components ( analysis         ,
	                                entries          ,
	                                components       )

	name = SELECT versioned_c_l_entry . name
	       FOR UPDATE
	       WHERE ( analysis         = analysis            ) AND
	             ( analysis_version = analysis_version    ) AND
	             ( comp_list        = component_list      )

	WHILE name <> EMPTY DO

		position = work_profile_find_analysis_component ( analysis   ,
								  name       ,
								  components )

		IF position <> EMPTY THEN

			component = components [ position ]
			component . not_updated = FALSE

			entry = entries [ component . position ]

			ASSIGN versioned_c_l_entry . order_number =
					entry . component_order

			ASSIGN versioned_c_l_entry . replicate_count =
					entry . replicates

			entry . write_others ( "VERSIONED_C_L_ENTRY" )

			IF lib_comp_has_category ( component . component ,
						   CATEGORY_SURROGATE    ) THEN

				ASSIGN versioned_c_l_entry . surrogate_mlp =
						spec_header

			ELSE

				ASSIGN versioned_c_l_entry . surrogate_mlp =
						NULL

			ENDIF

			UPDATE versioned_c_l_entry

			component . not_updated = FALSE

		ELSE

			DELETE versioned_c_l_entry

		ENDIF

		NEXT versioned_c_l_entry

		name = SELECT versioned_c_l_entry . name

	ENDWHILE

	position = 1

	WHILE position <= size_of_array ( components ) DO

		component = components [ position ]

		IF component . not_updated THEN

			entry = entries [ component . position ]

			RESERVE ENTRY versioned_c_l_entry ,
				      analysis             :
				      analysis_version     :
				      component_list       :
				      entry . component

			ASSIGN versioned_c_l_entry . order_number =
					entry . component_order

			ASSIGN versioned_c_l_entry . replicate_count =
					entry . replicates

			entry . write_others ( "VERSIONED_C_L_ENTRY" )

			IF lib_comp_has_category ( component . component ,
						   CATEGORY_SURROGATE    ) THEN

				ASSIGN versioned_c_l_entry . surrogate_mlp =
						spec_header

			ELSE

				ASSIGN versioned_c_l_entry . surrogate_mlp =
						NULL

			ENDIF

			UPDATE versioned_c_l_entry

		ENDIF

		position = position + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_component_lists  ( VALUE spec_header      ,
						     entries          ,
						     active_analyses  ,
						     deleted_analyses )

{
*
*
*******************************************************************************}

	DECLARE count    ,
		analysis

	count = 1

	WHILE count <= size_of_array ( active_analyses ) DO

		analysis = active_analyses [ count ]

		work_profile_update_component_list_header
		              ( analysis . component_list   ,
		                analysis . analysis         ,
		                analysis . analysis_version )

		work_profile_update_component_list_entries
		              ( spec_header                 ,
				analysis . component_list   ,
		                analysis . analysis         ,
		                analysis . analysis_version ,
		                entries                     )

		count = count + 1

	ENDWHILE

	count = 1

	WHILE count <= size_of_array ( deleted_analyses ) DO

		analysis = deleted_analyses [ count ]

		work_profile_delete_a_component_list
		                          ( spec_header                 ,
		                            analysis . analysis         ,
		                            analysis . analysis_version )

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_use_a_limit_phrase (       entries      ,
					  VALUE position     ,
					        limit_phrase )

{
*
*
*******************************************************************************}

	DECLARE entry            ,
		use_limit_phrase ,
		inc_code         ,
		old_format

	entry = entries [ position ]
        use_limit_phrase = FALSE

	IF entry . is_type ( "T" ) THEN

		limit_phrase = SELECT limit . text_phrase IN OBJECT entry . limits

		IF NOT blank ( limit_phrase ) THEN

			use_limit_phrase = TRUE

		ELSEIF position = size_of_array ( entries ) THEN

			use_limit_phrase = FALSE

		ELSEIF ( entries [ position + 1 ] . is_textual ()) THEN

			use_limit_phrase = TRUE

		ELSE

			use_limit_phrase = entry . comparison <> "P"

		ENDIF


		IF ( use_limit_phrase     ) AND
		   ( blank ( limit_phrase )) THEN

			old_format = global ( "FORMAT_TEXT" )

			SET FORMAT "9999999999"

			inc_code     = INCREMENT ( "SPECIFICATION" ,
						   "LIMIT_PHRASE"  )

			inc_code     = STRIP ( inc_code )
    			inc_code     = JUSTIFY ( PAD( inc_code, " ", 10 ), "RIGHT" )

			limit_phrase = "S" : STRIP ( inc_code )
			limit_phrase = PAD ( limit_phrase , " " , 10 )

			ASSIGN limit . text_phrase IN OBJECT entry . limits =
				limit_phrase

			SET FORMAT old_format

		ENDIF

	ENDIF

	RETURN ( use_limit_phrase )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_phrase_header ( VALUE limit_header ,
					   VALUE spec_header  )


{
*
*
*******************************************************************************}

	DECLARE temp

	temp = SELECT limit_phrase_header . identity
	       FOR UPDATE
	       WHERE identity = limit_header

	IF temp = EMPTY THEN


		RESERVE ENTRY limit_phrase_header , limit_header

	ENDIF

	ASSIGN limit_phrase_header . description = SELECT mlp_header . description
	ASSIGN limit_phrase_header . group_id    = SELECT mlp_header . group_id

	ASSIGN limit_phrase_header . modified_on = now
	ASSIGN limit_phrase_header . modified_by = operator


	UPDATE limit_phrase_header

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_phrase_entries ( VALUE limit_header ,
					    VALUE spec_header  ,
						  entries      ,
					          position     )


{
*
*
*******************************************************************************}

	DECLARE updated       ,
		count         ,
		compare_value ,
		entry         ,
		found         ,
		start

	ARRAY updated

        compare_value = SELECT limit_phrase_entry . result_value
		        FOR UPDATE
		        WHERE limit_phrase = limit_header

	WHILE compare_value <> EMPTY DO

		count = position

		REPEAT

			entry = entries [ count ]

			found = entry . textual_value = compare_value

		UNTIL    ( found )
	              OR ( NOT work_profile_is_text_comparison ( entries [ count ] ))


		IF found THEN

			ASSIGN limit_phrase_entry . order_number = count -
								   position + 1
			ASSIGN limit_phrase_entry . comparison =
							  entry . comparison


			UPDATE limit_phrase_entry

			updated [ count ] = TRUE

		ELSE

			DELETE limit_phrase_entry

		ENDIF

		count = count + 1

                NEXT limit_phrase_entry
	        compare_value = SELECT limit_phrase_entry . result_value


	ENDWHILE

	start = position

	REPEAT

 		IF updated [ position ] = EMPTY THEN

			entry = entries [ position ]

			RESERVE ENTRY limit_phrase_entry, limit_header :
							  entry . textual_value

			ASSIGN limit_phrase_entry . order_number = position -
								   start + 1
			ASSIGN limit_phrase_entry . comparison =
							  entry . comparison

			UPDATE limit_phrase_entry

		ENDIF

		position = position + 1

	UNTIL NOT work_profile_is_text_comparison ( entries [ position ] )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_textual_comparison (       entries     ,
					        VALUE position    ,
						VALUE spec_header )

{
*
*
*******************************************************************************}

	DECLARE entry        ,
		limit_phrase

	entry = entries [ position ]

	IF entry . is_type ( "T" ) THEN

		REPEAT

			entry = entries [ position ]

			IF work_profile_use_a_limit_phrase ( entries      ,
							    position     ,
							    limit_phrase ) THEN

	     			work_profile_update_phrase_header ( limit_phrase ,
								   spec_header  )
				work_profile_update_phrase_entries ( limit_phrase ,
								    spec_header  ,
								    entries      ,
								    position     )

				ASSIGN limit . text_spec
					IN OBJECT entry . limits = ""


		        ELSE

				ASSIGN limit . text_phrase
					IN OBJECT entry . limits = ""

				ASSIGN limit . text_spec
					IN OBJECT entry . limits = entry . textual_value

				position = position + 1

			ENDIF

		UNTIL ( position > size_of_array ( entries ))              OR
		      ( NOT ( work_profile_is_level ( entries [ position ] )))

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_a_mlp_component ( VALUE spec_header ,
                                              VALUE mlp_version ,
                                              VALUE analysis    )

{
*
*
*******************************************************************************}

	DECLARE temp       ,
		entry_code

	temp = SELECT mlp_components . analysis_id
	       FOR UPDATE
	       WHERE ( product_id      = spec_header ) AND
	             ( product_version = mlp_version ) AND
	             ( analysis_id     = analysis    )

	WHILE temp <> EMPTY DO

		entry_code = SELECT mlp_components . entry_code

		limit_mod_delete ( entry_code )

		DELETE mlp_components

		NEXT mlp_components

		temp = SELECT mlp_components . analysis_id

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_mlp_components ( VALUE spec_header      ,
                                             VALUE mlp_version      ,
                                                   deleted_analyses )

{
*
*
*******************************************************************************}

	DECLARE count

	count = 1

	WHILE count <= size_of_array ( deleted_analyses ) DO

		work_profile_delete_a_mlp_component (
		                       spec_header                           ,
		                       mlp_version                           ,
		                       deleted_analyses [ count ] . analysis )

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_a_mlp_component (       spec_header    ,
					            component      ,
					            entries        ,
					            level_list     ,
					      VALUE old_entry_code )

{
*
*
*******************************************************************************}

	DECLARE entry


	component . not_updated = FALSE
	entry     = entries [ component . position ]

	IF old_entry_code <> EMPTY THEN

		IF old_entry_code <> entry . entry_code THEN

			limit_mod_delete_levels ( level_list     ,
						  old_entry_code )

		ENDIF

	ENDIF

	ASSIGN mlp_components . component_type = entry . component_type
	ASSIGN mlp_components . places         = entry . dp
	ASSIGN mlp_components . units          = entry . units
	ASSIGN mlp_components . entry_code     = entry . entry_code
	ASSIGN mlp_components . order_num      = component . order_number

	UPDATE mlp_components

	work_profile_update_textual_comparison ( entries              ,
					        component . position ,
						spec_header          )

	limit_mod_update ( level_list         ,
			   entry . entry_code )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_mlp_components ( VALUE spec_header      ,
                                             VALUE mlp_version      ,
                                             VALUE analysis         ,
                                                   entries          ,
                                                   level_entry_code )

{
*
*
*******************************************************************************}

	DECLARE name               ,
		position           ,
		components         ,
		component          ,
		entry              ,
		entry_code         ,
		level_list         ,
		deleted_level_list ,
                mlp_version_temp


	work_profile_build_components ( analysis   ,
				        entries    ,
				        components )

	level_mod_deleted_level_list ( level_entry_code   ,
				       deleted_level_list )

	level_mod_active_level_list ( "MODIFY"          ,
				       level_entry_code ,
				       level_list       )

	name = SELECT mlp_components . component_name
	       FOR UPDATE
	       WHERE ( product_id      = spec_header ) AND
		     ( product_version = mlp_version ) AND
		     ( analysis_id     = analysis    )

	WHILE name <> EMPTY DO

		entry_code = SELECT mlp_components . entry_code

		position = work_profile_find_analysis_component ( analysis   ,
								  name       ,
								  components )

		IF position <> EMPTY THEN

			component = components [ position ]

			work_profile_update_a_mlp_component ( spec_header ,
							      component   ,
							      entries     ,
							      level_list  ,
							      entry_code  )

			limit_mod_delete_levels ( deleted_level_list ,
						  entry_code         )

		ELSE


			DELETE mlp_components
			limit_mod_delete ( entry_code )

		ENDIF

		NEXT mlp_components

		name = SELECT mlp_components . component_name

	ENDWHILE

	position = 1

	WHILE position <= size_of_array ( components ) DO

		component = components [ position ]

		IF component . not_updated THEN

			entry = entries [ component . position ]

                        extract_mlp_version ( mlp_version_temp, spec_header )

			RESERVE ENTRY mlp_components ,  spec_header       :
						        mlp_version       :
							analysis          :
							entry . component

			work_profile_update_a_mlp_component ( spec_header ,
							      component   ,
							      entries     ,
							      level_list  ,
							      EMPTY       )

		ENDIF

		position = position + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_mlp_header ( VALUE spec_header      ,
					 VALUE mlp_version      ,
					 VALUE level_entry_code ,
					       levels           )

{
*
*
*******************************************************************************}

	DECLARE temp       ,
		entry_code ,
		record_lock_state

	temp = EMPTY

	IF ( spec_header = SELECT mlp_header . identity )        AND
	   ( mlp_version = SELECT mlp_header . product_version ) THEN

		record_lock_state = LOCK_STATE ( "MLP_HEADER" )

		IF ( record_lock_state = "SELECTED_WRITE" ) OR
		   ( record_lock_state = "RESERVED_WRITE" ) THEN

			temp = SELECT mlp_header . identity

		ENDIF

	ENDIF

	IF temp = EMPTY THEN

		temp = SELECT mlp_header . identity
		       FOR UPDATE
		       WHERE ( identity        = spec_header )
	                 AND ( product_version = mlp_version )

	ENDIF

	IF temp = EMPTY THEN

		entry_code = level_entry_code

		RESERVE ENTRY mlp_header , spec_header :
                                           mlp_version

	       	ASSIGN mlp_header . entry_code = entry_code

	ELSE

		entry_code = SELECT mlp_header . entry_code

		IF entry_code = 0 THEN

			entry_code = level_entry_code
		       	ASSIGN mlp_header . entry_code = entry_code

		ENDIF

	ENDIF

        ASSIGN mlp_header . test_schedule = work_profile_spec_header_to_test_sched ( spec_header )

	ASSIGN mlp_header . description   = SELECT test_sched_header . description
	ASSIGN mlp_header . group_id      = SELECT test_sched_header . group_id

	ASSIGN mlp_header . modified_on   = now
	ASSIGN mlp_header . modified_by   = operator

	UPDATE mlp_header

	level_mod_save ()

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_mlp_schedule ( VALUE spec_header ,
					   VALUE mlp_version ,
			                         entries     )
{
*
*
*******************************************************************************}


	DECLARE mlp_id	   ,
		position   ,
		schedules  ,
		schedule

	work_profile_build_schedule_array ( entries   ,
				            schedules )

	mlp_id = SELECT mlp_schedule . mlp_id
	         FOR UPDATE
	         WHERE ( identity         = spec_header ) AND
		       ( identity_version = mlp_version )

	WHILE mlp_id <> EMPTY DO

		position = work_profile_schedule_active ( mlp_id    ,
							  schedules )


		IF position <> 0 THEN

			schedule = schedules [ position ]
			schedule . not_updated = FALSE


		ELSE

			DELETE mlp_schedule

		ENDIF

		NEXT mlp_schedule

		mlp_id = SELECT mlp_schedule . mlp_id

	ENDWHILE

	position = 1

	WHILE position <= size_of_array ( schedules ) DO

		schedule = schedules [ position ]

		IF schedule . not_updated THEN

			RESERVE ENTRY mlp_schedule , spec_header         :
						     mlp_version         :
					             schedule . schedule

			UPDATE mlp_schedule

		ENDIF

		position = position + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_update_mlp  ( VALUE spec_header      ,
				   VALUE mlp_version      ,
			                 entries          ,
				   VALUE level_entry_code ,
					 levels           ,
				         active_analyses  ,
				         deleted_analyses )

{
*
*
*******************************************************************************}

	DECLARE count    ,
		analysis

	work_profile_update_mlp_header ( spec_header      ,
					 mlp_version      ,
					 level_entry_code ,
					 levels           )

	work_profile_update_mlp_schedule ( spec_header ,
					   mlp_version ,
					   entries     )

	count = 1

	WHILE count <= size_of_array ( active_analyses ) DO

		analysis = active_analyses [ count ] . analysis

		work_profile_update_mlp_components ( spec_header      ,
						     mlp_version      ,
						     analysis         ,
						     entries          ,
						     level_entry_code )

		count = count + 1

	ENDWHILE

	work_profile_delete_mlp_components ( spec_header      ,
	                                     mlp_version      ,
	                                     deleted_analyses )

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_update_data ( VALUE spec_header      ,
				   VALUE mlp_version      ,
				   VALUE is_batch         ,
					 entries          ,
					 level_entry_code ,
					 levels           ,
					 deleted_analyses )
{
*
*
*******************************************************************************}

	DECLARE active_analyses

	work_profile_build_analysis_array ( spec_header     ,
					    entries         ,
					    active_analyses )

	work_profile_update_test_schedule ( spec_header      ,
					    entries          ,
					    active_analyses  ,
				            deleted_analyses )

	work_profile_update_component_lists ( spec_header      ,
					      entries          ,
					      active_analyses  ,
					      deleted_analyses )

	work_profile_update_mlp ( spec_header      ,
				  mlp_version      ,
				  entries          ,
				  level_entry_code ,
				  levels           ,
				  active_analyses  ,
				  deleted_analyses )


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_data_valid ( entries        ,
				  goto_column    ,
				  goto_row       )

{
*
*
*******************************************************************************}

	DECLARE count     ,
		entry     ,
		valid     ,
		redisplay


        valid = TRUE
	count = 1

	WHILE ( count <= size_of_array ( entries )) AND
	      ( valid                             ) DO

		entry = entries [ count ]

		IF entry . limits <> EMPTY THEN

			IF NOT entry . limits . validate ( redisplay ) THEN

				goto_row = count
				valid    = FALSE

			ENDIF

		ENDIF

		count = count + 1

	ENDWHILE

	IF NOT valid THEN

		count = 1

		WHILE count <= size_of_array ( work_profile_prompt_details ) DO

			IF work_profile_prompt_details [ count , 4 ] =
					"WORK_PROFILE_LOWER_LIMIT" THEN

				goto_column = count

			ENDIF

			count = count + 1

		ENDWHILE

	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_level_add_command (       changes      ,
					VALUE command      ,
					VALUE level_name   ,
					VALUE new_position )

{
*
*
*******************************************************************************}

	DECLARE pos

	pos = size_of_array ( changes ) + 1

	changes [ pos , 1 ] = command
	changes [ pos , 2 ] = level_name
	changes [ pos , 3 ] = new_position

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_level_find ( VALUE level_name     ,
				       old_level_list )

{
*
*
*******************************************************************************}

	DECLARE count

	count = 1

	WHILE count <= size_of_array ( old_level_list ) DO

		IF old_level_list [ count ] = level_name THEN

			RETURN ( count )

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_levels_determine_changes ( entries        ,
				               old_level_list ,
				               new_level_list ,
					       changes        )

{
*
*
*******************************************************************************}

	DECLARE count        ,
		old_position ,
		level_name   ,
		altered

	ARRAY changes ARRAY_SIZE ( 0 , 3 )

	altered = FALSE
	count   = 1

	WHILE count <= size_of_array ( new_level_list ) DO

		level_name   = new_level_list [ count ]

		old_position = work_profile_level_find ( level_name     ,
							old_level_list )

		IF old_position = 0 THEN

			work_profile_level_add_command ( changes              ,
							LEVEL_COMMAND_INSERT ,
							level_name           ,
							count                )
			altered = TRUE

		ELSE

			IF old_position <> count THEN

				altered = TRUE

			ENDIF

			work_profile_level_add_command ( changes            ,
							LEVEL_COMMAND_MOVE ,
							level_name         ,
							count              )
			old_level_list [ old_position ] = EMPTY

		ENDIF

		count = count + 1

	ENDWHILE

	count = 1

	WHILE count <= size_of_array ( old_level_list ) DO

		level_name   = old_level_list [ count ]

		IF level_name <> EMPTY THEN

			altered = TRUE
			work_profile_level_add_command ( changes              ,
							LEVEL_COMMAND_DELETE ,
							level_name           ,
							0                    )

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( altered )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_levels_find_level ( VALUE start_pos   ,
					      entries     ,
					VALUE level_name  )
{
*
*
*******************************************************************************}

	DECLARE position

	position = start_pos

	WHILE entries [ position ] . level <> level_name DO

		position = position + 1

	ENDWHILE

	RETURN ( position )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_levels_find_position ( VALUE start_pos   ,
					          entries     ,
					    VALUE level_order )
{
*
*
*******************************************************************************}

	DECLARE count     ,
		position

	count    = 1
	position = start_pos

	WHILE count <> level_order DO

		position = position + 1

		IF NOT work_profile_is_text_comparison ( entries [ position ] ) THEN

			count = count + 1

		ENDIF

	ENDWHILE

	RETURN ( position )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_levels_insert ( VALUE analysis    ,
				     VALUE component   ,
				     VALUE start_pos   ,
				      	   entries     ,
				     VALUE level_name  ,
				     VALUE level_order )

{
*
*
*******************************************************************************}


	DECLARE position   ,
		new_entry  ,
		levels     ,
		entry_code

	ARRAY levels
	levels [ 1 ] = level_name

	CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

	IF level_order = 1 THEN

		new_entry . analysis  = analysis
		new_entry . component = component

	ENDIF

	new_entry . actual_analysis  = analysis
	new_entry . actual_component = component

	entry_code = entries [ start_pos ] . entry_code

	position = work_profile_levels_find_position ( start_pos   ,
					               entries     ,
					               level_order )

	array_insert_slice ( entries  ,
			     1        ,
			     position )
	entries [ position ] = new_entry

	work_profile_setup_mlp_limits (  analysis   ,
				         component  ,
				        "MODIFY"    ,
					 entry_code ,
				         levels     ,
					 entries    ,
					 position   )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_levels_move ( VALUE analysis    ,
				   VALUE component   ,
				   VALUE start_pos   ,
				    	 entries     ,
				   VALUE level_name  ,
				   VALUE level_order )

{
*
*
*******************************************************************************}


	DECLARE new_position  ,
		old_position  ,
		keep_going    ,
		count         ,
		temp


	ARRAY temp

	new_position = work_profile_levels_find_position ( start_pos   ,
					                   entries     ,
					                   level_order )

	old_position = work_profile_levels_find_level ( start_pos   ,
					                entries     ,
					                level_name  )


	keep_going = TRUE
	count      = 1

	WHILE keep_going DO

		temp [ count ] = entries [ old_position ]

		array_remove_slice ( entries      ,
				     1            ,
				     old_position )

		count = count + 1

		keep_going = work_profile_is_text_comparison ( entries [ old_position ] )

	ENDWHILE


	count = 1

	WHILE count <= size_of_array ( temp ) DO

		array_insert_slice ( entries      ,
				     1            ,
				     new_position )

		entries [ new_position ] = temp [ count ]

		IF ( level_order = 1 ) AND
		   ( count       = 1 ) THEN

			entries [ new_position ] . analysis  = analysis
			entries [ new_position ] . component = component

		ELSE

			entries [ new_position ] . analysis  = ""
			entries [ new_position ] . component = ""

		ENDIF

		new_position = new_position + 1
		count        = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_levels_delete ( VALUE start_pos   ,
					   entries     ,
				     VALUE level_name  )

{
*
*
*******************************************************************************}


	DECLARE old_position ,
		keep_going

	old_position = work_profile_levels_find_level ( start_pos   ,
					                entries     ,
					                level_name  )

	keep_going = TRUE

	WHILE keep_going DO

		array_remove_slice ( entries      ,
				     1            ,
				     old_position )

		keep_going = work_profile_is_text_comparison ( entries [ old_position ] )

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_levels_perform_changes ( VALUE analysis  ,
					      VALUE component ,
					      VALUE start_pos ,
						    entries   ,
					            changes   )

{
*
*
*******************************************************************************}

	DECLARE command

	command = 1

	WHILE command <= size_of_array ( changes ) DO

		IF changes [ command , 1 ] = LEVEL_COMMAND_INSERT THEN

			work_profile_levels_insert ( analysis                ,
						     component               ,
						     start_pos               ,
						     entries                 ,
						     changes [ command , 2 ] ,
						     changes [ command , 3 ] )


		ELSEIF changes [ command , 1 ] = LEVEL_COMMAND_MOVE THEN

			work_profile_levels_move ( analysis                ,
						   component               ,
						   start_pos               ,
						   entries                 ,
						   changes [ command , 2 ] ,
						   changes [ command , 3 ] )

		ELSEIF changes [ command , 1 ] = LEVEL_COMMAND_DELETE THEN

			work_profile_levels_delete ( start_pos               ,
						     entries                 ,
						     changes [ command , 2 ] )

		ENDIF

		command = command + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_change_levels ( VALUE entry_code ,
					   grid       ,
					   entries    )

{
*
*
*******************************************************************************}

	DECLARE old_levels ,
		new_levels ,
		changes    ,
		analysis   ,
		component  ,
		count      ,
		entry


	level_mod_active_level_list (  grid . mode ,
				       entry_code  ,
				       old_levels  )

	REPEAT

		level_mod_screen ( grid . mode ,
				   entry_code  )


		level_mod_active_level_list ( grid . mode ,
					      entry_code  ,
					      new_levels  )

		IF ( size_of_array ( new_levels ) = 0 ) AND
                   ( grid . mode <> "DISPLAY" ) THEN

			flash_message ( get_user_message ( "WORK_PROFILE_NO_LEVELS" , 1 ) ,
					TRUE                                              )

		ENDIF

	UNTIL size_of_array ( new_levels ) > 0

	IF work_profile_levels_determine_changes ( entries    ,
						   old_levels ,
						   new_levels ,
						   changes    ) THEN

		count = 1

		WHILE count <= size_of_array ( entries ) DO

			entry = entries [ count ]

			IF work_profile_is_analysis ( entry ) THEN

				analysis = entry . analysis

			ELSEIF work_profile_is_component ( entry ) THEN

				component = entry . component
				work_profile_levels_perform_changes ( analysis ,
								      component,
								      count    ,
								      entries  ,
								      changes  )

			ENDIF

			count = count + 1

		ENDWHILE

		grid . levels    = new_levels
		grid . cell_rows = size_of_array ( entries )
		grid . rebuild ()


	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_type (       self       ,
			         grid        ,
			   VALUE cell_column ,
			   VALUE cell_row    ,
			   VALUE column      ,
			   VALUE row         ,
			   VALUE cell_width  ,
				 screen      ,
			   VALUE is_display  )

{
*
*
*******************************************************************************}

	DECLARE type       ,
		anal_type  ,
		schd_type

	anal_type  = get_user_message ( "WORK_PROFILE_ANAL_TYPE"  , 1 )
	schd_type = get_user_message ( "WORK_PROFILE_SCHD_TYPE" , 1 )


	IF is_display THEN

		IF work_profile_is_analysis ( self ) THEN

			type = anal_type

		ELSEIF work_profile_is_schedule ( self ) THEN

			type = schd_type

		ELSEIF work_profile_is_component ( self ) THEN

			type = "    "

		ELSEIF work_profile_is_level ( self ) THEN

			type = "    "

		ELSEIF work_profile_is_text_comparison ( self ) THEN

			type = "    "

		ELSEIF grid . is_batch THEN

			type = "    "

		ELSE

			IF grid . insert_analysis THEN

				type = anal_type

			ELSE

				type = schd_type

			ENDIF

		ENDIF

		DISPLAY type ON LINE row
			     FROM    column
			     TO      column + cell_width - 1
			     IN WINDOW screen

	ELSEIF ( grid . cell_rows = grid . current_row ) AND
	       ( NOT grid . is_batch 	               ) THEN

		PROMPT FOR grid . insert_analysis
		       ON LINE row
		       FROM    column
		       TO      column + cell_width - 1
		       IN WINDOW screen
		       BROWSE ON Boolean
		       WITH ( true_word  = anal_type ,
			      false_word = schd_type )

	ELSE


		PROMPT ON LINE row
		       FROM    column
		       TO      column + cell_width - 1
		       IN WINDOW screen

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_validate_analysis ( VALUE analysis ,
					      entries  )

{
*
*
*******************************************************************************}

	DECLARE valid    ,
		count    ,
		entry    ,
		message

	valid    = TRUE

	IF NOT blank ( analysis ) THEN

		count = 1

		WHILE count <= size_of_array ( entries ) DO

			entry = entries [ count ]

			IF entry . analysis = analysis THEN

				valid = FALSE

			ENDIF

			count = count + 1

	        ENDWHILE

	ENDIF

	IF NOT valid THEN

		message_fetch ( "WORK_PROFILE_ANALYSIS_ON" , message )
		message_add_parameter ( message , strip ( analysis ))

		flash_message ( message_get_text ( message , 1 ) ,
				TRUE                             )

	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_validate_schedule ( VALUE schedule ,
					       entries  )

{
*
*
*******************************************************************************}

	DECLARE valid    ,
		count    ,
		entry    ,
		message

	valid    = TRUE

	IF NOT blank ( schedule ) THEN

		count = 1

		WHILE count <= size_of_array ( entries ) DO

			entry = entries [ count ]

			IF entry . schedule = schedule THEN

				valid = FALSE

 			ENDIF

			count = count + 1

	        ENDWHILE

	ENDIF

	IF NOT valid THEN

		message_fetch ( "WORK_PROFILE_SCHEDULE_ON" , message )
		message_add_parameter ( message , strip ( schedule ))

		flash_message ( message_get_text ( message , 1 ) ,
				TRUE                             )

	ENDIF

	IF schedule = SELECT test_sched_header . identity THEN

		message_fetch ( "WORK_PROFILE_NESTED_PROFILE" , message )
		message_add_parameter ( message , strip ( schedule ))

		flash_message ( message_get_text ( message , 1 ) ,
				TRUE                             )

        	valid = FALSE

	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_prompt_analysis (       self        ,
				             grid        ,
			               VALUE cell_column ,
			               VALUE cell_row    ,
				       VALUE column      ,
				       VALUE row         ,
				       VALUE cell_width  ,
				             screen      ,
				       VALUE is_display  )
{
*
*
*******************************************************************************}

	DECLARE analysis     ,
		can_leave    ,
		current_row

	current_row = grid . current_row

	REPEAT

		PROMPT FOR analysis
		       ON LINE row
		       FROM    column
		       TO      column + cell_width - 1
		       IN WINDOW screen
		       BROWSE ON analysis

		IF ( lastkey <> "EXIT"   ) AND
		   ( lastkey <> "REMOVE" ) THEN

			can_leave = work_profile_validate_analysis ( analysis       ,
                                                                     grid . entries )

		ELSE

			can_leave = TRUE
			analysis  = ""

			ENDIF

	UNTIL can_leave

	IF NOT blank ( analysis ) THEN

		CLEAR LINE row
		      FROM column
		      TO   column + cell_width - 1
		      IN WINDOW screen

		IF work_profile_insert_analysis ( analysis         ,
						  ""               ,
					          grid             ,
					          grid . cell_rows ) THEN

			work_profile_insert_all_components ( analysis         ,
							     ""               ,
							     TRUE             ,
							     TRUE             ,
							     grid . entries   ,
							     grid . levels    ,
						             grid             ,
						             grid . cell_rows )

			grid . set_position ( grid . current_column ,
					      current_row           )

			SET GLOBAL "LASTKEY" TO "CONTINUE"

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_prompt_schedule (       self        ,
				             grid        ,
			               VALUE cell_column ,
			               VALUE cell_row    ,
				       VALUE column      ,
				       VALUE row         ,
				       VALUE cell_width  ,
				             screen      ,
				       VALUE is_display  )
{
*
*
*******************************************************************************}

	DECLARE schedule  ,
		can_leave

	REPEAT

		PROMPT FOR schedule
		       ON LINE row
		       FROM    column
		       TO      column + cell_width - 1
		       IN WINDOW screen
		       BROWSE ON test_sched_header

		IF ( lastkey <> "EXIT"   ) AND
		   ( lastkey <> "REMOVE" ) THEN

			can_leave = work_profile_validate_schedule ( schedule       ,
                                                                    grid . entries )


		ELSE

			can_leave = TRUE
			schedule  = ""

			ENDIF

	UNTIL can_leave

	IF NOT blank ( schedule ) THEN

		CLEAR LINE row
		      FROM column
		      TO   column + cell_width - 1
		      IN WINDOW screen

		work_profile_insert_schedule ( schedule         ,
					      grid             ,
					      grid . cell_rows )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_analysis_component (       self        ,
			                        grid        ,
			                  VALUE cell_column ,
			                  VALUE cell_row    ,
			                  VALUE column      ,
			                  VALUE row         ,
			                  VALUE cell_width  ,
				                screen      ,
			                  VALUE is_display  )

{
*
*
*******************************************************************************}


	IF work_profile_is_analysis ( self ) THEN

		IF is_display THEN

			DISPLAY self . analysis
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				BOLD
				IN WINDOW screen

		ELSE


			PROMPT  FOR self . analysis
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen
				BROWSE ON analysis
				WITH ( display_only = TRUE ,
				       bold         = TRUE )

		ENDIF

	ELSEIF work_profile_is_component ( self ) THEN

		IF is_display THEN

			DISPLAY self . component
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen

		ELSE


			PROMPT  FOR self . component
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen
				WITH ( display_only = TRUE )

		ENDIF

	ELSEIF work_profile_is_schedule ( self ) THEN

		IF is_display THEN

			DISPLAY self . schedule
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				BOLD
				IN WINDOW screen

		ELSE


			PROMPT  FOR self . schedule
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen
				WITH ( display_only = TRUE ,
				       bold         = TRUE )

		ENDIF

	ELSE

		IF is_display THEN


		ELSEIF ( grid . current_row = grid . cell_rows ) AND
		       ( NOT grid . is_batch   	               ) THEN

			IF grid . insert_analysis THEN

				work_profile_prompt_analysis ( self       ,
							      grid        ,
		                	                      cell_column ,
			                                      cell_row    ,
							      column      ,
							      row         ,
							      cell_width  ,
							      screen      ,
							      is_display  )

			ELSE


				work_profile_prompt_schedule ( self        ,
							       grid        ,
			                                       cell_column ,
			                                       cell_row    ,
							       column      ,
							       row         ,
							       cell_width  ,
							       screen      ,
							       is_display  )

			ENDIF

		ELSE

			PROMPT FOR nothing
			       ON LINE   row
			       FROM      column
			       TO        column + cell_width - 1
			       IN WINDOW screen
			       WITH ( display_only = TRUE )

		ENDIF



	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_repeat (       self        ,
			            grid        ,
			      VALUE cell_column ,
			      VALUE cell_row    ,
			      VALUE column      ,
			      VALUE row         ,
			      VALUE cell_width  ,
			            screen      ,
			      VALUE is_display  )

{
*
*
*******************************************************************************}

	IF ( self . is_level      ()                   )   OR
	   ( self . is_schedule   ()                   )   OR
	   ( self . is_textual    ()                   )   OR
	   (( self . is_component ()                   )   AND
	    ( NOT global ( "RESULT_REPLICATES_ENABLED" ))) THEN

		IF is_display THEN

			CLEAR LINE row
			      FROM column
			      TO   column + cell_width - 1
			      IN WINDOW screen

		ELSE

			PROMPT FOR nothing
			       ON LINE   row
			       FROM      column
			       TO        column + cell_width - 1
			       IN WINDOW screen
			       WITH ( display_only = TRUE )

		ENDIF

	ELSEIF is_display THEN

		SET FORMAT "999"

		DISPLAY strip ( self . replicates )
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen


	ELSE


		PROMPT  FOR self . replicates
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			BROWSE ON integer
        		WITH ( minimum = 0   ,
			       maximum = 999 )
	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_validate_dp_prompt ( self )

{
*	Validates the prompt for significant figures etc.
*
*******************************************************************************}

	DECLARE return_value

	return_value = FALSE

	IF STRIP ( self . text ) <> "X" THEN

		IF NUMERIC ( self . text ) <> ERROR THEN
			IF NUMERIC ( self . text ) >= 0 THEN
				return_value = TRUE
			ENDIF
		ENDIF

	ELSE

		return_value = TRUE

	ENDIF

	RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_dp (       self        ,
			        grid        ,
			  VALUE cell_column ,
			  VALUE cell_row    ,
			  VALUE column      ,
			  VALUE row         ,
			  VALUE cell_width  ,
			        screen      ,
			  VALUE is_display  )

{
*
*
*******************************************************************************}


 	DECLARE component_type ,
       	 	dec_places     ,
		original_value ,
		the_val

	component_type = self . component_type
	dec_places     = self . dp

	IF is_display THEN

		IF component_type = "N" THEN

			display_dp ( dec_places ,
				     screen     ,
				     column     ,
				     row        )

		ELSE

			CLEAR LINE      row
			      FROM      column
			      TO        column + cell_width - 1
			      IN WINDOW	screen

		ENDIF

	ELSEIF component_type = "N" THEN

		original_value = dec_places

		IF dec_places = -1 THEN

			the_val = "X"

		ELSE

			the_val = STRIP ( number_to_text ( dec_places , "9"))

		ENDIF

		PROMPT FOR       the_val
	   	       ON LINE   row
	               FROM      column
	               IN WINDOW screen
	               CHOOSE OUTOF work_profile_places_browse_array
	               WITH ( always_validate = TRUE                              ,
		              validation_routine = "work_profile_validate_dp_prompt" ,
	  	              is_spin = TRUE                                      )

		IF the_val = "X" THEN

			dec_places = -1

		ELSE

			dec_places = NUMERIC ( the_val )

		ENDIF

		IF ( lastkey <> "EXIT"            ) AND
		   ( original_value <> dec_places ) THEN

			self . dp = dec_places

		ENDIF

	ELSE

		PROMPT FOR nothing
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			WITH ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_change_limit_type (       self           ,
				         VALUE component_type ,
					       grid           )

{
*
*
*******************************************************************************}

	DECLARE level_list   ,
		current_row  ,
		entry        ,
		entry_code

	entry_code            = self . entry_code
	self . component_type = component_type

	level_mod_active_level_list ( "MODIFY"                 ,
				       grid . level_entry_code ,
				       level_list              )

	limit_mod_change_type ( level_list     ,
		                entry_code     ,
				component_type )

	level_mod_deleted_level_list ( grid . level_entry_code ,
			               level_list              )

	limit_mod_change_type ( level_list     ,
		                entry_code     ,
			        component_type )

	current_row = grid . current_row

	REPEAT

		entry = grid . entries [ current_row ]
		entry . limits = limit_mod_find_limit ( "MODIFY"                ,
					                 entry . level          ,
						         entry_code             ,
						         EMPTY                  ,
						         entry . component_type ,
						         entry . dp             ,
						         entry . units          )

		grid . redisplay_row ( current_row )

		current_row = current_row + 1

	UNTIL NOT grid . entries [ current_row ] . is_level ()


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_component_type (       self        ,
			                    grid        ,
			              VALUE cell_column ,
			              VALUE cell_row    ,
			              VALUE column      ,
			              VALUE row         ,
			              VALUE cell_width  ,
			                    screen      ,
			              VALUE is_display  )

{
*
*
*******************************************************************************}

	DECLARE types ,
		type

	IF is_display THEN

		IF ( self . is_component ()) THEN

			DISPLAY self . component_type
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen

		ENDIF

	ELSEIF ( self . is_component ()) THEN

		ARRAY types

		types [1,1] = "B"
		types [1,2] = "B"

		types [2,1] = "I"
		types [2,2] = "I"

		types [3,1] = "N"
		types [3,2] = "N"

		types [4,1] = "T"
		types [4,2] = "T"

		type = self . component_type

		PROMPT  FOR type
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			CHOOSE OUTOF types
			WITH ( is_spin = TRUE )

		IF type <> self . component_type THEN

			work_profile_change_limit_type ( self ,
						        type ,
						        grid )

		ENDIF

	ELSE

		PROMPT FOR nothing
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			WITH ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_level (       self        ,
			           grid        ,
			     VALUE cell_column ,
			     VALUE cell_row    ,
			     VALUE column      ,
			     VALUE row         ,
			     VALUE cell_width  ,
			           screen      ,
			     VALUE is_display  )

{
*
*
*******************************************************************************}

	IF is_display THEN

		DISPLAY self . level
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen

	ELSE


		PROMPT  FOR self . level
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			BROWSE ON display
			WITH ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_standard (       self        ,
			                 grid        ,
			           VALUE cell_column ,
			           VALUE cell_row    ,
			           VALUE column      ,
			           VALUE row         ,
			           VALUE cell_width  ,
			                 screen      ,
			           VALUE is_display  )

{
*
*
*******************************************************************************}

	IF self . is_analysis () THEN

		IF is_display THEN

			DISPLAY self . is_standard
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen
				FORMAT test_sched_entry . std_test

		ELSE

			PROMPT  FOR self . is_standard
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen
				FORMAT test_sched_entry . std_test

		ENDIF

	ELSE

		IF is_display THEN

		ELSE

			PROMPT FOR nothing
			       ON LINE   row
			       FROM      column
			       TO        column + cell_width - 1
			       IN WINDOW screen
			       WITH ( display_only = TRUE )

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_validate_units (       self            ,
				      VALUE units           ,
				      VALUE display_message )

{
*
*
*******************************************************************************}

	DECLARE old_units     ,
		valid         ,
		error_message ,
		message

	IF strip ( units ) <> strip ( self . units ) THEN

 		old_units = SELECT component . units
			    WHERE ( analysis = self . actual_analysis  ) AND
				  ( name     = self . actual_component )

		valid =  unit_check_units ( old_units     ,
					    units         ,
					    error_message )

 		IF ( NOT valid           ) AND
		   (     display_message ) THEN

			message_fetch ( "WORK_PROFILE_UNITS_INCOM" , message )
			message_add_parameter ( message , strip ( units     ))
			message_add_parameter ( message , strip ( old_units ))

			flash_message ( message_get_text ( message , 1 ) ,
					TRUE                             )

		ENDIF

	ELSE

		valid = TRUE

	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_units (       self        ,
			           grid        ,
			     VALUE cell_column ,
			     VALUE cell_row    ,
			     VALUE column      ,
			     VALUE row         ,
			     VALUE cell_width  ,
			           screen      ,
			     VALUE is_display  )

{
*
*
*******************************************************************************}

	DECLARE valid_units ,
		units       ,
		count

	IF is_display THEN

		DISPLAY self . units
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen

	ELSEIF ( self . is_component ()) AND
	       ( self . is_type ( "N" )) THEN

		units = self . units

		REPEAT

			PROMPT  FOR units
				CLASS UNIT_PROMPT_CLASS
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen


			IF lastkey = "EXIT" THEN

				valid_units = TRUE

			ELSE

				valid_units = work_profile_validate_units ( self  ,
			                                                    units ,
									    TRUE  )

			ENDIF

		UNTIL valid_units

		self . units = units

		count = grid . current_row + 1

		WHILE grid . entries [ count ] . is_level () DO

			grid . entries [ count ] . units = units
			grid . redisplay_cell ( grid . current_column ,
						count                 )

			count = count + 1

		ENDWHILE

	ELSE


		PROMPT  FOR self . units
			CLASS UNIT_PROMPT_CLASS
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			WITH ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_valid_textual_limit ( VALUE textual_limit ,
			                         entries       ,
			                   VALUE position      )

{
*
*
*******************************************************************************}

	DECLARE valid   ,
		count   ,
		message


	IF blank ( textual_limit ) THEN

		valid = TRUE

	ELSE

		valid = TRUE
		count = position

		WHILE ( NOT work_profile_is_level     ( entries [ count ] )) AND
		      ( NOT work_profile_is_component ( entries [ count ] )) DO

			count = count - 1

		ENDWHILE


		IF count <> position THEN

			IF strip ( entries [ count ] . textual_value ) =
			   strip ( textual_limit                     ) THEN

				valid = FALSE

			ENDIF

		ENDIF

		count = count + 1

		WHILE ( work_profile_is_text_comparison ( entries [ count ] )) DO

			IF count <> position THEN

				IF strip ( entries [ count ] . textual_value ) =
				   strip ( textual_limit                     ) THEN

					valid = FALSE

  				ENDIF

			ENDIF

			count = count + 1


		ENDWHILE

		IF NOT valid THEN

			message_fetch ( "WORK_PROFILE_TEXTUAL_EXISTS" , message )
			message_add_parameter ( message , strip ( textual_limit ))

			flash_message ( message_get_text ( message , 1 ) ,
					TRUE                             )


		ENDIF

	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_blank_textual (       grid        ,
				     VALUE current_row )

{
*
*
*******************************************************************************}

	DECLARE next_entry ,
		self

	self       = grid . entries [ current_row     ]
	next_entry = grid . entries [ current_row + 1 ]

	IF work_profile_is_text_comparison ( next_entry ) THEN

		self . textual_value = next_entry . textual_value
		self . comparison    = next_entry . comparison

		work_profile_delete_row ( grid            ,
				         current_row + 1 )

		grid . redisplay_row ( current_row )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_textual_limit (       self       ,
			                   grid       ,
			   VALUE cell_column ,
			   VALUE cell_row    ,
			             VALUE column     ,
			             VALUE row        ,
			             VALUE cell_width ,
			                   screen     ,
			             VALUE is_display )

{
*
*
*******************************************************************************}

	DECLARE current_row ,
		can_leave

	IF is_display THEN

		DISPLAY self . textual_value
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen

	ELSE

		REPEAT

			PROMPT FOR self . textual_value
			       ON LINE   row
			       FROM      column
			       TO        column + cell_width - 1
			       IN WINDOW screen

			IF lastkey <> "EXIT" THEN

				can_leave = work_profile_valid_textual_limit ( self . textual_value ,
									      grid . entries       ,
									      grid . current_row   )

			ELSE

				can_leave = TRUE

			ENDIF

		UNTIL can_leave

		IF blank ( self . textual_value ) THEN

			current_row = grid . current_row

			IF ( work_profile_is_level     ( self )) OR
			   ( work_profile_is_component ( self ))	THEN

				work_profile_blank_textual ( grid        ,
							    current_row )

			ELSE

				work_profile_delete_row ( grid        ,
							 current_row )

			ENDIF

		ENDIF


	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_lower_limit (       self        ,
			                 grid        ,
			           VALUE cell_column ,
			           VALUE cell_row    ,
			           VALUE column      ,
			           VALUE row         ,
			           VALUE cell_width  ,
			                 screen      ,
			           VALUE is_display  )

{
*
*
*******************************************************************************}

	DECLARE limit

	IF self . is_type ( "T" ) THEN

		work_profile_textual_limit ( self       ,
					    grid       ,
					    cell_column ,
					    cell_row    ,
					    column     ,
					    row        ,
					    cell_width ,
					    screen     ,
					    is_display )

	ELSEIF is_display THEN

		IF self . limits <> EMPTY THEN

			limit = self . limits . display ( 1 )

		ELSE

			limit = ""

		ENDIF

		DISPLAY limit
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen

	ELSEIF ( self . limits <> EMPTY                                     ) AND
               ( SELECT limit . entry_code IN OBJECT self . limits <> EMPTY ) THEN

		self . limits . places =  grid . entries [ cell_row ] . dp

		self . limits . prompt ( 1                     ,
				         grid                  ,
				         grid . current_column ,
				         grid . current_row    ,
				         column                ,
				         row                   ,
				         screen                ,
				         cell_width            )

	ELSE

		PROMPT FOR nothing
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen
		       WITH ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_upper_limit (       self        ,
			                 grid        ,
			           VALUE cell_column ,
			           VALUE cell_row    ,
			           VALUE column      ,
			           VALUE row         ,
			           VALUE cell_width  ,
			                 screen      ,
			           VALUE is_display  )

{
*
*
*******************************************************************************}

	DECLARE limit

	IF is_display THEN

		IF self . is_type ( "T" ) THEN


			DISPLAY self . comparison
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
       				IN WINDOW screen
			        FORMAT    limit_phrase_entry . comparison

		ELSEIF self . is_type ( "B" ) THEN


			DISPLAY "Pass"
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
       				IN WINDOW screen

		ELSE

			IF self . limits <> EMPTY THEN

				limit = self . limits . display ( 2 )
			ELSE

				limit = ""

			ENDIF

			DISPLAY limit
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen

		ENDIF

	ELSEIF self . is_type ( "T" ) THEN

		PROMPT FOR self . comparison
		       ON LINE row
		       FROM    column
		       TO      column + cell_width - 1
		       IN WINDOW screen
		       FORMAT  limit_phrase_entry . comparison

	ELSEIF self . is_type ( "B" ) THEN

		PROMPT
		       ON LINE row
		       FROM    column
		       TO      column + cell_width - 1
		       IN WINDOW screen

	ELSEIF ( self . limits <> EMPTY ) AND
               ( SELECT limit . entry_code IN OBJECT self . limits <> EMPTY ) THEN

		self . limits . places =  grid . entries [ cell_row ] . dp

		self . limits . prompt ( 2                     ,
				         grid                  ,
				         grid . current_column ,
				         grid . current_row    ,
				         column                ,
				         row                   ,
				         screen                ,
				         cell_width            )

	ELSE

		PROMPT FOR nothing
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen
		       WITH ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_limit_calc (       self        ,
			                grid        ,
			          VALUE cell_column ,
			          VALUE cell_row    ,
			          VALUE column      ,
			          VALUE row         ,
			          VALUE cell_width  ,
			                screen      ,
			          VALUE is_display  )

{
*
*
*******************************************************************************}

	DECLARE limit

	IF is_display THEN

		IF self . limits <> EMPTY THEN

			limit = SELECT limit . calculation
				IN OBJECT self . limits

			IF limit = EMPTY THEN

				limit = ""

			ENDIF

		ELSE

			limit = ""

		ENDIF

		DISPLAY limit
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen

	ELSEIF ( self . limits <> EMPTY ) AND
               ( SELECT limit . entry_code IN OBJECT self . limits <> EMPTY ) THEN

		limit = SELECT limit . calculation IN OBJECT self . limits

		PROMPT FOR  limit
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen
		       BROWSE ON limit_calculation

		IF lastkey <> "EMPTY" THEN

			ASSIGN limit . calculation IN OBJECT self . limits
								= limit

		ENDIF

	ELSE

		PROMPT FOR nothing
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen
		       WITH ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_spike (       self        ,
			           grid        ,
			     VALUE cell_column ,
			     VALUE cell_row    ,
			     VALUE column      ,
			     VALUE row         ,
			     VALUE cell_width  ,
			           screen      ,
			     VALUE is_display  )

{
*
*
*******************************************************************************}

	DECLARE position      ,
		allowed       ,
		display_value

	position = cell_column
	allowed  = FALSE

	allowed = self . is_component ()

	IF self . is_component () THEN

		allowed = lib_comp_has_category ( self . component   ,
						  CATEGORY_READING   )


	ELSE

		allowed = FALSE

	ENDIF

	IF allowed THEN

		IF is_display THEN

			display_value = self . other_fields [ position ]

			IF display_value = EMPTY THEN

				get_field_details versioned_c_l_entry .
						  spike_value
						  "DEFAULT_VALUE" ,
						   display_value

				self . other_fields [ position ] = display_value

			ENDIF

			DISPLAY display_value
				ON LINE   row
				FROM      column
				TO        column + cell_width - 1
				IN WINDOW screen
				FORMAT versioned_c_l_entry . spike_value


		ELSE

			display_value = self . other_fields [ position ]

			IF display_value = EMPTY THEN

				display_value = ""

			ENDIF

			PROMPT FOR display_value
			       ON LINE   row
			       FROM      column
			       TO        column + cell_width - 1
			       IN WINDOW screen
			       FORMAT versioned_c_l_entry . spike_value

			IF lastkey <> "EXIT" THEN

				self . other_fields [ position ] = display_value

			ENDIF

		ENDIF

	ELSE

		IF is_display THEN



		ELSE

			PROMPT FOR nothing
			       ON LINE   row
			       FROM      column
			       TO        column + cell_width - 1
			       IN WINDOW screen
			       WITH ( display_only = TRUE )

		ENDIF

	ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_other (       self        ,
			           grid        ,
			     VALUE cell_column ,
			     VALUE cell_row    ,
			     VALUE column      ,
			     VALUE row         ,
			     VALUE cell_width  ,
			           screen      ,
			     VALUE is_display  )

{
*
*
*******************************************************************************}

	DECLARE other         ,
		position      ,
		allowed       ,
		display_value ,
		field_type

	position = cell_column
	other    = work_profile_other_fields [ position ]
	allowed  = FALSE

	IF INDEX ( other . allowed_for , PROMPT_ON_SCHEDULE ) <> 0 THEN

		allowed = self . is_schedule ()

	ENDIF

	IF INDEX ( other . allowed_for , PROMPT_ON_ANALYSIS ) <> 0 THEN

		allowed = self . is_analysis ()

	ENDIF

	IF INDEX ( other . allowed_for , PROMPT_ON_COMPONENT ) <> 0 THEN

		allowed = self . is_component ()

	ENDIF

	IF INDEX ( other . allowed_for , PROMPT_ON_LEVEL ) <> 0 THEN

		allowed = self . is_level ()

	ENDIF

	IF INDEX ( other . allowed_for , PROMPT_ON_TEXTUAL ) <> 0 THEN

		allowed = self . is_textual ()

	ENDIF


	IF allowed THEN

		get_field_details 'other . table' . 'other . field'
				  "DATA_TYPE" ,
				   field_type


		IF is_display THEN

			display_value = self . other_fields [ position ]

			IF display_value = EMPTY THEN

				get_field_details 'other . table' . 'other . field'
						  "DEFAULT_VALUE" ,
						   display_value

				self . other_fields [ position ] = display_value

			ENDIF

			IF field_type = "Boolean" THEN

				DISPLAY display_value
					ON LINE   row
					FROM      column
					TO        column + cell_width - 1
					IN WINDOW screen
					FORMAT 'other . table' . 'other . field'
                                        WITH ( is_check = TRUE )
			ELSE

				DISPLAY display_value
					ON LINE   row
					FROM      column
					TO        column + cell_width - 1
					IN WINDOW screen
					FORMAT 'other . table' . 'other . field'

			ENDIF

		ELSE

			display_value = self . other_fields [ position ]

			IF display_value = EMPTY THEN

				display_value = ""

			ENDIF

			IF field_type = "Boolean" THEN

				PROMPT FOR display_value
				       ON LINE   row
				       FROM      column
				       TO        column + cell_width - 1
				       IN WINDOW screen
				       FORMAT 'other . table' . 'other . field'
                                       WITH ( is_check = TRUE )


			ELSE

				PROMPT FOR display_value
				       ON LINE   row
				       FROM      column
				       TO        column + cell_width - 1
				       IN WINDOW screen
				       FORMAT 'other . table' . 'other . field'

			ENDIF

			IF lastkey <> "EXIT" THEN

				self . other_fields [ position ] = display_value

			ENDIF

		ENDIF

	ELSE

		IF is_display THEN



		ELSE

			PROMPT FOR nothing
			       ON LINE   row
			       FROM      column
			       TO        column + cell_width - 1
			       IN WINDOW screen
			       WITH ( display_only = TRUE )

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_display (       grid        ,
                               VALUE cell_column ,
		               VALUE cell_row    ,
			             screen      ,
		               VALUE column      ,
		               VALUE row         ,
			       VALUE cell_width  ,
			       VALUE cell_height )

{
*
*
*
*******************************************************************************}

	DECLARE object

        object = grid . entries [ cell_row ]

	lib_grid_display_array ( grid                       ,
				 cell_column                ,
				 cell_row                   ,
				 screen                     ,
				 column                     ,
				 row                        ,
				 cell_width                 ,
				 object                     ,
				 work_profile_prompt_details ,
				 "MLP_VERSIONS"             ,
				 FALSE                      ,
				 PROMPT_DETAILS_310         )


ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_prompt (       grid        ,
                              VALUE cell_column ,
		              VALUE cell_row    ,
			            screen      ,
		              VALUE column      ,
		              VALUE row         ,
			      VALUE cell_width  ,
			      VALUE cell_height )

	DECLARE object

        object = grid . entries [ cell_row ]

	lib_grid_prompt_array ( grid                       ,
				cell_column                ,
				cell_row                   ,
				screen                     ,
				column                     ,
				row                        ,
				cell_width                 ,
				object                     ,
				work_profile_prompt_details ,
				"MLP_VERSIONS"             ,
				FALSE                      ,
				PROMPT_DETAILS_310         )


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_select ( grid )

{
*
*
*******************************************************************************}

	DECLARE menu_options  ,
		option_number

        ARRAY menu_options ARRAY_SIZE ( 0, 4 )

        menu_options [ 1, 1 ] = "*"
        menu_options [ 1, 2 ] = get_user_message ( "WORK_PROFILE_MENU_OPTIONS",
						    1                         )

        menu_options [ 2, 1 ] = get_user_message ( "WORK_PROFILE_OPTION_PROPAGATE" ,
						    1                         )
        menu_options [ 2, 2 ] = get_user_message ( "WORK_PROFILE_OPTION_PROPAGATE" ,
						    2                         )
        menu_options [ 2, 3 ] = 1

        menu_options [ 3, 1 ] = get_user_message ( "WORK_PROFILE_OPTION_LEVELS" ,
						    1                         )
        menu_options [ 3, 2 ] = get_user_message ( "WORK_PROFILE_OPTION_LEVELS" ,
						    2                         )
        menu_options [ 3, 3 ] = 2


        CHOOSE option_number OUTOF menu_options
                ON LINE 10 FROM 20

	IF option_number = 1

		work_profile_propagate_main ( grid )

	ELSEIF option_number = 2 THEN

		work_profile_change_levels ( grid . level_entry_code ,
					     grid                    ,
					     grid . entries          )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_display_select ( grid )

{
*
*
*******************************************************************************}

	work_profile_change_levels ( grid . level_entry_code ,
				     grid                    ,
				     grid . entries          )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_insert_schedule ( form )

{
*
*
*******************************************************************************}

	DECLARE is_insert

	is_insert = NOT ( blank ( form . schedule . value )) AND
			( blank ( form . analysis . value ))

	RETURN ( is_insert )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_insert_analysis ( form )

{
*
*
*******************************************************************************}

	DECLARE is_insert        ,
		grid             ,
		current_analysis ,
		new_analysis

	grid = form . user_info

	current_analysis = work_profile_analysis_for_entry ( grid . current_row ,
							    grid . entries     )

	new_analysis = form . analysis . value

	IF NOT blank ( new_analysis ) THEN

		is_insert = current_analysis <> new_analysis

	ELSE

		is_insert = FALSE

	ENDIF

	RETURN ( is_insert )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_insert_component ( form )

{
*
*
*******************************************************************************}

	DECLARE is_insert

	is_insert = NOT blank ( form . component . value )

	RETURN ( is_insert )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_insert_all_components ( form )

{
*
*
*******************************************************************************}

	DECLARE is_insert

	is_insert = NOT blank ( form . analysis  . value        ) AND
		        blank ( form . component . value        ) AND
			NOT   ( form . component . display_only )

	RETURN ( is_insert )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_is_insert_textual_limit ( form )

{
*
*
*******************************************************************************}

	DECLARE is_insert

	is_insert = NOT blank ( form . textual . value )

	RETURN ( is_insert )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_validate_schedule ( form )

{
*
*
*******************************************************************************}

	DECLARE grid     ,
		schedule ,
		valid    ,
		entry

	grid     = form . user_info
        schedule = form . schedule . value

        entry    = grid . entries [ grid . current_row ]

	IF ( entry . is_analysis ()                 ) OR
	   ( entry . is_schedule ()                 ) OR
	   ( grid  . current_row = grid . cell_rows ) THEN

		valid = work_profile_validate_schedule ( schedule       ,
							 grid . entries )

	ELSE

		flash_message ( get_user_message ( "WORK_PROFILE_INV_PROFILE_POINT" , 1 ),
				TRUE                                                    )

		valid = FALSE

	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_validate_analysis ( form )

{
*
*
*******************************************************************************}

	DECLARE grid     ,
		analysis ,
		valid


	grid     = form . user_info
        analysis = form . analysis . value

	valid    = work_profile_validate_analysis ( analysis       ,
						    grid . entries )

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_find_analysis (       entries   ,
				     VALUE analysis  )

{
*
*
*******************************************************************************}

	DECLARE count ,
		entry

	count = 1

	WHILE count <= size_of_array ( entries ) DO

		entry = entries [ count ]

		IF entry . analysis = analysis THEN

			RETURN ( TRUE )

		ENDIF

		count = count + 1

        ENDWHILE

	RETURN ( FALSE )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_find_component (       entries   ,
				      VALUE analysis  ,
				      VALUE component )

{
*
*
*******************************************************************************}

	DECLARE count ,
		entry

	count = 1

	WHILE count <= size_of_array ( entries ) DO

		entry = entries [ count ]

		IF entry . analysis = analysis THEN

			IF entry . component = component THEN

				RETURN ( TRUE )

			ENDIF

		ENDIF

		count = count + 1

        ENDWHILE

	RETURN ( FALSE )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_validate_component ( form )

{
*
*
*******************************************************************************}

	DECLARE valid     ,
		grid      ,
		analysis  ,
		component ,
		name      ,
		message

	grid      = form . user_info
        analysis  = form . analysis  . value
	component = form . component . value

	valid     = NOT work_profile_find_component ( grid . entries ,
						      analysis       ,
						      component      )

	IF NOT valid THEN

		message_fetch ( "WORK_PROFILE_COMPONENT_EXISTS" , message )
		message_add_parameter ( message , strip ( component ))

		flash_message ( message_get_text ( message , 1 ) ,
				TRUE                             )

	ELSE

		name = SELECT component . name
		       WHERE  ( name     = component ) AND
			      ( analysis = analysis  )

		IF name = EMPTY THEN

			message_fetch ( "WORK_PROFILE_INV_COMPONENT" , message )
			message_add_parameter ( message , strip ( component ))
			message_add_parameter ( message , strip ( analysis  ))

			flash_message ( message_get_text ( message , 1 ) ,
					TRUE                             )

			valid = FALSE

		ENDIF

	ENDIF


	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_validate_textual_limit ( form )

{
*
*
*******************************************************************************}

	DECLARE grid          ,
		textual_limit ,
		acceptable

	grid          = form . user_info
	textual_limit = form . textual . value

	acceptable = work_profile_valid_textual_limit ( textual_limit      ,
						        grid . entries     ,
						        grid . current_row )

	RETURN ( acceptable )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_validation ( form )

{
*
*
*******************************************************************************}

	DECLARE acceptable


	IF work_profile_is_insert_analysis ( form ) THEN

		acceptable = work_profile_insert_validate_analysis ( form )

	ELSEIF work_profile_is_insert_component ( form ) THEN

		acceptable = work_profile_insert_validate_component ( form )

	ELSEIF work_profile_is_insert_schedule ( form ) THEN

		acceptable = work_profile_insert_validate_schedule ( form )

	ELSEIF work_profile_is_insert_textual_limit ( form ) THEN

		acceptable = work_profile_insert_validate_textual_limit ( form )

	ELSE

		acceptable = TRUE

	ENDIF

	RETURN ( acceptable )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_leave_schedule ( self )

{
*
*
*******************************************************************************}
{
	DECLARE analysis

	IF NOT blank ( self . value ) THEN

		analysis = self . parent_prompt . analysis
		analysis . value = ""
		analysis . text  = ""

		analysis . repaste ()

	ENDIF
}
ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_leave_analysis ( self )

{
*
*
*******************************************************************************}
{
	DECLARE schedule

	IF NOT blank ( self . value ) THEN

		schedule = self . parent_prompt . schedule
		schedule . value = ""
		schedule . text  = ""

		schedule . repaste ()

	ENDIF
}
ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_component_browse ( self )

{
*
*
*******************************************************************************}

	DECLARE analysis     ,
		browse_array ,
		name         ,
		count        ,
		category     ,
		can_use      ,
		temp         ,
		form

	ARRAY browse_array

	temp = lib_comp_add_category ( "" , CATEGORY_READING , EMPTY )
	temp = lib_comp_get_category ( temp )

	form = self . parent_prompt

	analysis = form . analysis . value

	count = 1

	name  = SELECT component . name
		WHERE  analysis = analysis
		ORDER ON order_number

	WHILE name <> EMPTY DO

		category = lib_comp_get_category ( name )

		IF blank ( category ) THEN

			can_use = TRUE

		ELSEIF form . insert_all_cats = EMPTY THEN

			can_use = TRUE

		ELSEIF form . insert_all_cats . value THEN

			can_use = TRUE

		ELSEIF form . insert_reading_cat . value THEN

			can_use = category = temp

		ELSE

			can_use = FALSE

		ENDIF

		IF can_use THEN

		        browse_array [ count , 1 ] = name
		        browse_array [ count , 2 ] = name


			count = count + 1

		ENDIF

		NEXT component

		name  = SELECT component . name

	ENDWHILE

	browse_on_array ( 40 , self . value , browse_array )

	self . text = self . value
	self . repaste ()

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_create_form ( form ,
					  grid )

{
*
*
*******************************************************************************}

	DECLARE message           ,
		display_column    ,
		terminator        ,
		schedule          ,
		analysis          ,
		component         ,
		textual           ,
		insert_all        ,
		insert_reading    ,
		current_row       ,
		entry             ,
		allow_insert_cats


	current_row = grid . current_row
	entry       = grid . entries [ current_row ]

	IF global ( "TERMTYPE" ) <> "GUI" THEN

		terminator = ":"

	ELSE

		terminator = ""

	ENDIF

	display_column = 15

	PROMPT OBJECT form
	       CLASS WORK_PROFILE_INSERT_FORM
	       ON LINE 10 FROM 6
	       WITH ( help_context     = "$WORK_PROFILE_INSERT"            ,
	              header           = get_user_message ( "WORK_PROFILE_INSERT_TITLE" , 1 )   ,
		      width            = 65                                ,
		      height           = 3                                 ,
		      return_behaviour = FORM_RETURN_WRAP                  ,
		      vgl_library      = global ( "current_library" )      ,
		      validation_routine = "work_profile_insert_validation" )

	message = get_user_message ( "WORK_PROFILE_INSERT_SCHEDULE" ,1 )
	message = pad ( message , " " , display_column - 4 ) : terminator

	form . add_display ( message                   ,
			     2                         ,
			     1                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )


	PROMPT OBJECT schedule
	       ON LINE 1
	       FROM    display_column
	       BROWSE ON test_sched_header
               WITH ( leave_prompt_routine = "WORK_PROFILE_INSERT_LEAVE_SCHEDULE",
		      vgl_library          = global ( "current_library" ),
		      enabled              = NOT grid . is_batch        )

	form . schedule = schedule
	form . add_prompt ( schedule )

	message = get_user_message ( "WORK_PROFILE_INSERT_ANALYSIS" , 1 )
	message = pad ( message , " " , display_column - 4 ) : terminator

	form . add_display ( message                   ,
			     2                         ,
			     2                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )



	PROMPT OBJECT analysis
	       ON LINE 2
	       FROM    display_column
	       BROWSE ON analysis
               WITH ( leave_prompt_routine = "WORK_PROFILE_INSERT_LEAVE_ANALYSIS",
		      vgl_library          = global ( "current_library" ),
		      enabled              = NOT grid . is_batch        )

	IF NOT entry . is_schedule () THEN

		analysis . value = work_profile_analysis_for_entry ( current_row    ,
							            grid . entries )

	ENDIF

	form . analysis  = analysis
	form . add_prompt ( analysis )


	message = get_user_message ( "WORK_PROFILE_INSERT_COMPONENT" , 1 )
	message = pad ( message , " " , display_column - 4 ) : terminator

	form . add_display ( message                   ,
			     2                         ,
			     3                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )


	PROMPT OBJECT component
	       ON LINE 3
	       FROM    display_column
	       TO      display_column + 20
	       WITH ( vgl_library    = global ( "current_library"    ))

	form . component = component
	form . add_prompt ( component )


	IF ( entry . is_level   ()) OR
	   ( entry . is_textual ()) THEN

		component . display_only = TRUE

	ELSE


		component . browse_routine = "work_profile_component_browse"


	ENDIF

	PROMPT OBJECT textual
	       ON LINE 4
	       FROM    display_column


	IF entry . is_type ( "T" ) THEN

		form . height = form . height + 1

		message = get_user_message ( "WORK_PROFILE_INSERT_TEXTUAL" , 1 )
		message = pad ( message , " " , display_column - 4 ) : terminator

		form . add_display ( message                   ,
				     2                         ,
				     4                         ,
				     PROMPT_RENDITION_BOLD     +
				     PROMPT_RENDITION_RAISED   )

		form . add_prompt ( textual )

	ENDIF

	form . textual = textual

	IF ( entry . is_schedule  ()         ) OR
	   ( entry . is_analysis  ()         ) OR
	   ( entry . is_component ()         ) OR
	   ( current_row = grid . cell_rows ) THEN

		analysis . display_only = entry . is_component ()
		schedule . display_only = FALSE
		allow_insert_cats       = TRUE

	ELSE

		analysis . display_only = TRUE
		schedule . display_only = TRUE
		allow_insert_cats       = FALSE

	ENDIF

	IF allow_insert_cats THEN

		display_column = 62

		message = get_user_message ( "WORK_PROFILE_INSERT_ALL_CATS" , 1 )
		message = pad ( message , " " , 23 ) : terminator

		form . add_display ( message                   ,
				     37                        ,
				     1                         ,
				     PROMPT_RENDITION_BOLD     +
				     PROMPT_RENDITION_RAISED   )


		PROMPT OBJECT insert_all
		       ON LINE 1
		       FROM    display_column
		       BROWSE ON BOOLEAN
		       WITH ( is_check = TRUE ,
			      value    = TRUE )

		form . insert_all_cats = insert_all
		form . add_prompt ( insert_all )

		message = get_user_message ( "WORK_PROFILE_INSERT_READ_CAT" , 1 )
		message = pad ( message , " " , 23 ) : terminator

		form . add_display ( message                   ,
				     37                        ,
				     2                         ,
				     PROMPT_RENDITION_BOLD     +
				     PROMPT_RENDITION_RAISED   )


		PROMPT OBJECT insert_reading
		       ON LINE 2
		       FROM    display_column
		       BROWSE ON BOOLEAN
		       WITH ( is_check = TRUE ,
			      value    = TRUE )

		form . insert_reading_cat = insert_reading
		form . add_prompt ( insert_reading )

	ELSE

		form . insert_all_cats = EMPTY

	ENDIF

	form . add_frame ( ""            ,
			   1             ,
			   1	         ,
			   form . height ,
			   form . width  )

	form . user_info = grid


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_a_line (       new_entry ,
					   entries   ,
					   grid      ,
				     VALUE grid_row  )

{
*
*
*******************************************************************************}

	array_insert_slice ( entries   ,
			     1         ,
			     grid_row  )

	entries [ grid_row ] = new_entry

	IF grid <> EMPTY THEN

		grid . insert_row ( grid_row            ,
				    1                   ,
				    GRID_SEPARATOR_NONE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_analysis ( VALUE analysis ,
				       VALUE schedule ,
				             grid     ,
				       VALUE grid_row )

{
*
*
*******************************************************************************}

	DECLARE new_entry        ,
		done_it          ,
		all_locked       ,
		analysis_version ,
		count

	IF NOT work_profile_analysis_version ( analysis, analysis_version ) THEN

		done_it = FALSE

	ELSEIF work_profile_lock_analysis (  analysis         ,
	                                     analysis_version ,
	                                    "EDIT"            ,
	                                     all_locked       ) THEN

		CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

		new_entry . analysis         = analysis
		new_entry . analysis_version = analysis_version
		new_entry . replicates       = 1

		IF NOT blank ( schedule ) THEN

			schedule = SELECT test_sched_entry . analysis_id
				   WHERE  ( identity    = schedule ) AND
                                          ( analysis_id = analysis )

			IF schedule <> EMPTY THEN

				new_entry . is_standard = SELECT test_sched_entry . std_test

				new_entry . read_others ( "TEST_SCHED_ENTRY" )

			ENDIF

		ENDIF

		work_profile_insert_a_line ( new_entry      ,
					     grid . entries ,
					     grid           ,
					     grid_row       )

		count = 1

		WHILE count <= size_of_array ( grid . deleted_analyses ) DO

			IF grid . deleted_analyses [ count ] . analysis
							 = analysis THEN

				array_remove_slice ( grid . deleted_analyses ,
						     1                       ,
						     count                   )

				count = size_of_array ( grid . deleted_analyses )

			ENDIF

			count = count + 1

		ENDWHILE

		done_it = TRUE

	ELSE

		done_it = FALSE

	ENDIF

	RETURN ( done_it )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_schedule ( VALUE schedule ,
					     grid     ,
				       VALUE grid_row )

{
*
*
*******************************************************************************}

	DECLARE new_entry

	CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

	new_entry . schedule       = schedule
        new_entry . replicates     = 1

	work_profile_insert_a_line ( new_entry      ,
				     grid . entries ,
				     grid           ,
				     grid_row       )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_phrase (       new_entry ,
				     VALUE phrase_id ,
					   entries   ,
		                           grid      ,
				           grid_row  )

{
*
*
*******************************************************************************}

	DECLARE analysis ,
	        component

	analysis  = new_entry . actual_analysis
	component = new_entry . actual_component

	phrase_id = SELECT phrase . phrase_text
		    WHERE  ( phrase_type = phrase_id ) AND
	                   ( phrase_text <> " "      )
        	    ORDER ON order_num

	IF phrase_id <> EMPTY THEN

		new_entry . textual_value = phrase_id

	ENDIF

	work_profile_insert_a_line ( new_entry  ,
				     entries    ,
				     grid       ,
				     grid_row   )

	NEXT phrase
	phrase_id = SELECT phrase . phrase_text

	WHILE phrase_id <> EMPTY DO

		grid_row = grid_row + 1

		CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

		new_entry . component_type   = "T"
		new_entry . textual_value    = phrase_id
		new_entry . actual_analysis  = analysis
		new_entry . actual_component = component

		work_profile_insert_a_line ( new_entry  ,
					     entries    ,
					     grid       ,
					     grid_row   )

		NEXT phrase
		phrase_id = SELECT phrase . phrase_text


	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_want_component (       entries            ,
					     VALUE analysis           ,
					     VALUE component          ,
					     VALUE insert_all_cats    ,
					     VALUE insert_reading_cat )

{
*
*
*******************************************************************************}

	DECLARE temp     ,
		category ,
		can_use

	temp = lib_comp_add_category ( "" , CATEGORY_READING , EMPTY )
	temp = lib_comp_get_category ( temp )

	category = lib_comp_get_category ( component )

	IF blank ( category ) THEN

		can_use = TRUE

	ELSEIF insert_all_cats THEN

		can_use = TRUE

	ELSEIF insert_reading_cat THEN

		can_use = category = temp

	ELSE

		can_use = FALSE

	ENDIF

	IF can_use THEN

		can_use = NOT work_profile_find_component ( entries   ,
							    analysis  ,
							    component )

	ENDIF

	RETURN ( can_use )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_copy_schedule_list ( VALUE analysis           ,
					  VALUE schedule           ,
					  VALUE component          ,
					  VALUE insert_all_cats    ,
					  VALUE insert_reading_cat ,
					        entries            ,
					        levels             ,
					        grid               ,
					  VALUE grid_row           )

{
*
*
*******************************************************************************}

	DECLARE count       ,
		version     ,
		mlp_version ,
		entry_code  ,
		copy_entry  ,
		all_locked  ,
		position    ,
		old_size    ,
		new_size    ,
		temp

	position    = grid_row
	old_size    = size_of_array ( entries )

	IF NOT work_profile_analysis_version ( analysis, version ) THEN

		component = EMPTY

	ELSEIF NOT work_profile_mlp_version ( schedule, mlp_version ) THEN

		component = EMPTY

	ELSEIF NOT blank ( component ) THEN

		component = SELECT versioned_c_l_entry . name
			    WHERE ( analysis         = analysis     ) AND
				  ( analysis_version = version      ) AND
				  ( comp_list        = schedule     ) AND
				  ( name             = component    )
 			    ORDER ON order_number


	ELSE

		component = SELECT versioned_c_l_entry . name
			    WHERE ( analysis         = analysis     ) AND
				  ( analysis_version = version      ) AND
				  ( comp_list        = schedule     )
 			    ORDER ON order_number

	ENDIF

	WHILE component <> EMPTY DO

		IF work_profile_insert_want_component ( entries            ,
							analysis           ,
							component          ,
							insert_all_cats    ,
						        insert_reading_cat ) THEN

			temp = position

			work_profile_read_a_component ( analysis  ,
							version   ,
							component ,
							levels    ,
							entries   ,
							position  )

			copy_entry = SELECT mlp_components . entry_code
			             WHERE ( product_id      = schedule    ) AND
				           ( product_version = mlp_version ) AND
				           ( analysis_id     = analysis    ) AND
					   ( component_name  = component   )

			entry_code = limit_get_entry_code ()

			position   = temp

			IF copy_entry <> EMPTY THEN

				work_profile_read_mlp_limits ( entry_code ,
							       copy_entry ,
							      "COPY"      ,
							       levels     ,
							       entries    ,
							       position   ,
							       all_locked )

			ELSE

				work_profile_setup_mlp_limits ( analysis  ,
							        component ,
							        "COPY"    ,
								EMPTY     ,
							        levels    ,
							        entries   ,
							        position  )

			ENDIF

		ENDIF

		NEXT versioned_c_l_entry

		component = SELECT versioned_c_l_entry . name

	ENDWHILE

	new_size = size_of_array ( entries )

	count    = 1

	WHILE count <= new_size - old_size DO

		grid . insert_row ( grid_row + count - 1 ,
				    1                    ,
				    GRID_SEPARATOR_NONE  )

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_component ( VALUE analysis  ,
				        VALUE component ,
					VALUE schedule  ,
					      entries   ,
					      levels    ,
					      grid      ,
				              grid_row  )

{
*
*
*******************************************************************************}

	DECLARE new_entry          ,
		count              ,
		entry_code         ,
		phrase_id


	IF NOT blank ( schedule ) THEN

		work_profile_copy_schedule_list ( analysis  ,
						  schedule  ,
						  component ,
						  TRUE      ,
						  TRUE      ,
						  entries   ,
						  levels    ,
						  grid      ,
						  grid_row  )

	ELSE

		entry_code = limit_get_entry_code ()

		count = 1

		WHILE count <= size_of_array ( levels ) DO

			CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

			IF count = 1 THEN

				new_entry . analysis       = analysis
				new_entry . component      = component

			ENDIF

			new_entry . actual_analysis  = analysis
			new_entry . actual_component = component

			work_profile_setup_component_fields (  analysis         ,
							       component        ,
							       levels [ count ] ,
							       entry_code       ,
							      "MODIFY"         ,
							       new_entry       ,
   							       phrase_id       )

			IF NOT blank ( phrase_id ) THEN

				work_profile_insert_phrase ( new_entry  ,
							     phrase_id  ,
							     entries    ,
							     grid       ,
							     grid_row   )

			ELSE

      				work_profile_insert_a_line ( new_entry  ,
							     entries    ,
							     grid       ,
							     grid_row   )

	   		ENDIF

			grid_row = grid_row + 1
     			count    = count    + 1

		ENDWHILE

	ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_insert_all_components ( VALUE analysis           ,
					     VALUE schedule           ,
					     VALUE insert_all_cats    ,
					     VALUE insert_reading_cat ,
						   entries            ,
						   levels             ,
						   grid               ,
					     VALUE grid_row           )

{
*
*
*******************************************************************************}

	DECLARE component

	IF NOT blank ( schedule ) THEN

		work_profile_copy_schedule_list ( analysis           ,
						  schedule           ,
						  ""                 ,
						  insert_all_cats    ,
						  insert_reading_cat ,
						  entries            ,
						  levels             ,
						  grid               ,
						  grid_row           )

	ELSE

		component = SELECT component . name
		            WHERE  analysis = analysis
	        	    ORDER ON order_number

 		WHILE component <> EMPTY DO

			IF work_profile_insert_want_component ( entries            ,
							        analysis           ,
							        component          ,
							        insert_all_cats    ,
								insert_reading_cat ) THEN


				work_profile_insert_component ( analysis   ,
							        component  ,
								schedule   ,
								entries    ,
								levels     ,
							        grid       ,
							        grid_row   )

    			ENDIF

			NEXT component

			component = SELECT component . name

  		ENDWHILE

	ENDIF


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_entry_parent_component (       entries ,
                                              VALUE count   )

{
*
*	For the entry specified by count return the parent component
*
*******************************************************************************}

	DECLARE initial_count ,
	        searching

	initial_count = count
	searching     = TRUE

	WHILE searching DO

		IF count = 0 THEN

			{ Should never happen - but you never know }
			searching = FALSE
			count     = initial_count

		ELSEIF NOT blank ( entries [ count ] . component ) THEN

			searching = FALSE

		ELSE

			count = count - 1

		ENDIF

	ENDWHILE

	RETURN ( count )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_textual_limit ( VALUE textual_limit ,
						  grid          ,
					    VALUE grid_row      )

{
*
*
*******************************************************************************}

	DECLARE new_entry ,
	        parent

	CREATE OBJECT WORK_PROFILE_ENTRY, new_entry

	new_entry . component_type = "T"
	new_entry . textual_value  = textual_limit
	new_entry . comparison     = "P"

	parent = work_profile_entry_parent_component ( grid . entries ,
	                                               grid_row       )

	new_entry . actual_analysis  = grid . entries [ parent ] . analysis
	new_entry . actual_component = grid . entries [ parent ] . component

	work_profile_insert_a_line ( new_entry      ,
				     grid . entries ,
				     grid           ,
				     grid_row + 1   )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert_doit ( form ,
			           grid )

{
*
*
*******************************************************************************}

	DECLARE grid_row     ,
		current_line ,
		no_problem

	grid_row     = grid . current_row
	current_line = grid_row
	no_problem   = TRUE

	IF     ( work_profile_is_insert_schedule  ( form )) AND
	   NOT ( work_profile_is_insert_analysis  ( form )) AND
	   NOT ( work_profile_is_insert_component ( form )) THEN

		work_profile_insert_schedule ( form . schedule . value ,
					       grid                    ,
					       grid_row                )

	ENDIF

	IF work_profile_is_insert_analysis ( form ) THEN

		no_problem = work_profile_insert_analysis ( form . analysis . value ,
							    form . schedule . value ,
					                    grid                    ,
					                    grid_row                )

	ENDIF

	IF work_profile_is_analysis ( grid . entries [ grid_row ] ) THEN

		grid_row = grid_row + 1

	ENDIF

	IF ( work_profile_is_insert_component ( form )) AND
	   ( no_problem 	                      ) THEN

		work_profile_insert_component ( form . analysis  . value ,
					        form . component . value ,
					        form . schedule  . value ,
						grid . entries           ,
						grid . levels            ,
					        grid                     ,
					        grid_row                 )

	ENDIF


	IF     ( work_profile_is_insert_all_components ( form )) AND
	   NOT ( work_profile_is_insert_textual_limit  ( form )) AND
	       ( no_problem	                               ) THEN

		work_profile_insert_all_components ( form . analysis . value           ,
						     form . schedule . value           ,
						     form . insert_all_cats  . value   ,
						     form . insert_reading_cat . value ,
						     grid . entries                    ,
						     grid . levels                     ,
						     grid                              ,
						     grid_row                          )

	ENDIF

	IF work_profile_is_insert_textual_limit ( form ) THEN

		work_profile_insert_textual_limit ( form . textual . value ,
					            grid                    ,
					            grid_row                )

	ENDIF

	grid . set_position ( grid . current_column ,
			      current_line          )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_has_prompts ( form )

{
*
*
*******************************************************************************}

	DECLARE count       ,
		has_prompts

	has_prompts = FALSE
	count       = 1

	WHILE count <= size_of_array ( form . prompt_objects ) DO

		IF (     form . prompt_objects [ count ] . enabled      ) AND
		   (     form . prompt_objects [ count ] . visible      ) AND
		   ( NOT form . prompt_objects [ count ] . display_only ) THEN

			has_prompts = TRUE

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( has_prompts )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_insert ( grid )

{
*
*
*******************************************************************************}

	DECLARE form

	work_profile_insert_create_form ( form ,
					  grid )


	IF work_profile_has_prompts ( form ) THEN

		form . start_prompt ()
		form . wait_prompt  ()

		IF form . get_lastkey () = "DO" THEN

			work_profile_insert_doit ( form ,
						   grid )

		ENDIF

		form . end_prompt   ()

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_row (       grid       ,
				  VALUE delete_row )

{
*
*
*******************************************************************************}

	array_remove_slice ( grid . entries  ,
			     1               ,
			     delete_row      )

	grid . remove_row ( delete_row )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_analysis (       grid       ,
				       VALUE delete_row )

{
*
*
*******************************************************************************}

	DECLARE entries   ,
		analysis  ,
		position


	entries = grid . entries

	CREATE OBJECT WORK_PROFILE_ANALYSIS ,analysis

	analysis . analysis         = entries [ delete_row ] . analysis
	analysis . analysis_version = entries [ delete_row ] . analysis_version

	position = size_of_array ( grid . deleted_analyses ) + 1
	grid . deleted_analyses [ position ] = analysis

	REPEAT

		work_profile_delete_row ( grid       ,
					  delete_row )

	UNTIL ( work_profile_is_analysis ( entries [ delete_row ] )) OR
	      ( work_profile_is_schedule ( entries [ delete_row ] )) OR
	      ( delete_row = grid . cell_rows                      )


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_schedule (       grid       ,
				       VALUE delete_row )

{
*
*
*******************************************************************************}

	work_profile_delete_row ( grid       ,
			          delete_row )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_component (       grid       ,
                                        VALUE delete_row )

{
*
*
*******************************************************************************}

	DECLARE entries

	entries = grid . entries

	REPEAT

		work_profile_delete_row ( grid       ,
					  delete_row )

	UNTIL ( work_profile_is_analysis  ( entries [ delete_row ] )) OR
	      ( work_profile_is_component ( entries [ delete_row ] )) OR
	      ( work_profile_is_schedule  ( entries [ delete_row ] )) OR
	      ( delete_row = grid . cell_rows                      )


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_what_leave ( self )

{
*
*
*******************************************************************************}

	DECLARE form         ,
		other_value  ,
		other_prompt

	form = self . parent_prompt

	other_value  = NOT self . value

	IF self . tag = 1 THEN

		other_prompt = form . prompt_objects [ 2 ]

	ELSE

		other_prompt = form . prompt_objects [ 1 ]

	ENDIF

	IF other_prompt . value <> other_value THEN

		other_prompt . value = other_value
		other_prompt . repaste ()

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_delete_what (       grid        ,
				  VALUE current_row )

{
*
*
*******************************************************************************}

	DECLARE form           ,
		message        ,
		boolean_prompt

	PROMPT OBJECT form
	       CLASS  PROMPT_CLASS_FORM
	       ON LINE 10
	       FROM    3
	       WITH ( help_context     = "$WORK_PROFILE"               ,
	              header           = get_user_message ( "WORK_PROFILE_DELETE_TITLE" , 1 ) ,
		      width            = 60                            ,
		      height           = 4                             ,
		      return_behaviour = FORM_RETURN_WRAP	       )

	message = get_user_message ( "WORK_PROFILE_DELETE_COMPONENT" , 1 )

	form . add_display ( message                   ,
			     2                         ,
			     1                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )

	message = get_user_message ( "WORK_PROFILE_DELETE_TEXTUAL" , 1 )

	form . add_display ( message                   ,
			     2                         ,
			     2                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )

	PROMPT OBJECT boolean_prompt
	       ON LINE 1 FROM 20
	       BROWSE ON BOOLEAN
               WITH ( value                = TRUE                           ,
		      leave_prompt_routine = "WORK_PROFILE_DELETE_WHAT_LEAVE",
		      vgl_library          = global ( "current_library"     ))

	form . add_prompt ( boolean_prompt )

	PROMPT OBJECT boolean_prompt
	       ON LINE 2 FROM 20
	       BROWSE ON BOOLEAN
               WITH ( leave_prompt_routine = "WORK_PROFILE_DELETE_WHAT_LEAVE",
		      vgl_library          = global ( "current_library"     ))

	form . add_prompt ( boolean_prompt )

	form . add_frame ( ""            ,
			   1             ,
			   1	         ,
			   form . height ,
			   form . width  )


	form . start_prompt ()
	form . wait_prompt  ()

	IF form . get_lastkey () = "DO" THEN

		IF form . prompt_objects [ 1 ] . value THEN

                        work_profile_delete_component ( grid        ,
                                                       current_row )

		ELSE

                        work_profile_blank_textual ( grid        ,
						    current_row )

		ENDIF

	ENDIF

	form . end_prompt   ()

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_remove ( grid )

{
*
*
*******************************************************************************}

	DECLARE current_row  ,
		entries      ,
		count


	current_row = grid . current_row
        entries     = grid . entries

	IF ( work_profile_is_analysis ( entries [ current_row ] )) AND
	   ( NOT grid . is_batch                                 ) THEN

		work_profile_delete_analysis ( grid        ,
					      current_row )

	ELSEIF work_profile_is_schedule ( entries [ current_row ] ) THEN

		work_profile_delete_schedule ( grid        ,
					      current_row )

	ELSEIF work_profile_is_component ( entries [ current_row ] ) THEN


		IF entries [ current_row + 1 ] . is_textual () THEN

			work_profile_delete_what ( grid        ,
						  current_row )

  		ELSE

                        work_profile_delete_component ( grid        ,
                                                       current_row )
		ENDIF


	ELSEIF work_profile_is_level ( entries [ current_row ] ) THEN

		count = current_row

		WHILE NOT work_profile_is_component ( entries [ count ] ) DO

			count = count - 1

		ENDWHILE

		work_profile_delete_component ( grid  ,
					       count )

	ELSEIF work_profile_is_text_comparison ( entries [ current_row ] ) THEN

		work_profile_delete_row ( grid        ,
					 current_row )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_repeat (       entry           ,
					      copied_entry    ,
                                        VALUE is_set          ,
					      propagate_value )
{
*
*
*******************************************************************************}

	IF is_set THEN

		entry . replicates = propagate_value
	ELSE

		propagate_value = entry . replicates

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_type (       entry           ,
					    copied_entry    ,
                                      VALUE is_set          ,
					    propagate_value )

{
*
*
*******************************************************************************}

	IF is_set THEN

		entry . component_type = propagate_value

	ELSE

		propagate_value = entry . component_type

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_dp (       entry           ,
					  copied_entry    ,
                                    VALUE is_set          ,
					  propagate_value )

{
*
*
*******************************************************************************}

	IF is_set THEN

		IF propagate_value = "X" THEN
			entry . dp = -1
		ELSE
			entry . dp = propagate_value
		ENDIF

	ELSE

		IF entry . dp = -1 THEN
			propagate_value = "X"
		ELSE
			propagate_value = entry . dp
		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_lower (       entry           ,
					     copied_entry    ,
                                       VALUE is_set          ,
					     propagate_value )

{
*
*
*******************************************************************************}

	DECLARE type

	type = copied_entry . component_type

	IF entry . is_textual () THEN

	ELSEIF is_set THEN

		IF object_get_class_name ( entry . limits ) =
        	   object_get_class_name ( copied_entry . limits ) THEN

			IF type = "N" THEN

				ASSIGN limit . min_limit IN OBJECT entry . limits = propagate_value

			ELSEIF type = "I" THEN

				ASSIGN limit . min_limit IN OBJECT entry . limits = propagate_value

			ELSEIF type = "B" THEN

				ASSIGN limit . boolean_pass IN OBJECT entry . limits = propagate_value

			ENDIF

		ENDIF

	ELSE

		IF type = "N" THEN

			propagate_value = SELECT limit . min_limit IN OBJECT entry . limits

		ELSEIF type = "I" THEN

			propagate_value = SELECT limit . min_limit IN OBJECT entry . limits

		ELSEIF type = "B" THEN

			propagate_value = SELECT limit . boolean_pass IN OBJECT entry . limits

                ELSE

		        propagate_value = ""

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_upper (       entry           ,
					     copied_entry    ,
                                       VALUE is_set          ,
					     propagate_value )

{
*
*
*******************************************************************************}

	DECLARE type

	type = copied_entry . component_type

	IF entry . is_textual () THEN

		IF is_set THEN

			IF type = "T" THEN

				entry . comparison = propagate_value

			ENDIF

		ELSE

			propagate_value = entry . comparison

		ENDIF

	ELSEIF is_set THEN

		IF object_get_class_name ( entry . limits ) =
        	   object_get_class_name ( copied_entry . limits ) THEN

			IF type = "N" THEN

				ASSIGN limit . max_limit IN OBJECT entry . limits = propagate_value

			ELSEIF type = "I" THEN

				ASSIGN limit . max_limit IN OBJECT entry . limits = propagate_value

			ELSEIF type = "T" THEN

				entry . comparison = propagate_value

			ENDIF

		ENDIF

	ELSE

		IF type = "N" THEN

			propagate_value = SELECT limit . max_limit IN OBJECT entry . limits

		ELSEIF type = "I" THEN

			propagate_value = SELECT limit . max_limit IN OBJECT entry . limits

		ELSEIF type = "T" THEN

			propagate_value = entry . comparison

                ELSE

			propagate_value = ""

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_units (       entry           ,
					     copied_entry    ,
                                       VALUE is_set          ,
					     propagate_value )

{
*
*
*******************************************************************************}

	IF is_set THEN

		IF entry . component_type = "N" THEN

			IF work_profile_validate_units ( entry           ,
							 propagate_value ,
							 FALSE           ) THEN

       				entry . units = propagate_value

			ENDIF

		ENDIF

	ELSE

		propagate_value = entry . units

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_limit_calc (       entry           ,
					          copied_entry    ,
                                            VALUE is_set          ,
					          propagate_value )

{
*
*
*******************************************************************************}


	IF is_set THEN

		IF entry . limits <> EMPTY THEN

			ASSIGN limit . calculation IN OBJECT entry . limits = propagate_value

		ENDIF

	ELSE

		IF entry . limits <> EMPTY THEN

			propagate_value = SELECT limit . calculation IN OBJECT entry . limits

		ELSE

			propagate_value = ""

		ENDIF

	ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_propagate_standard (       entry           ,
					        copied_entry    ,
                                          VALUE is_set          ,
					        propagate_value )

{
*
*
*******************************************************************************}

	IF is_set THEN

		entry . is_standard = propagate_value

	ELSE

		propagate_value = entry . is_standard

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_other (       entry           ,
					     copied_entry    ,
                                       VALUE is_set          ,
				       VALUE other           ,
					     propagate_value )

{
*
*
*******************************************************************************}

	IF is_set THEN

		entry . other_fields [ other ] = propagate_value

	ELSE

		propagate_value = entry . other_fields [ other ]

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_call (       entry            ,
					    copied_entry     ,
				            propagate_value  ,
				      VALUE propagate_column ,
				      VALUE is_set 	     )
{
*
*
*******************************************************************************}

	DECLARE propagate_routine

	propagate_routine = work_profile_propagate [ propagate_column ]

	IF propagate_routine = ERROR THEN

		IF NOT is_set THEN

			propagate_value = ERROR

		ENDIF

	ELSEIF propagate_routine = EMPTY THEN

		work_profile_propagate_other ( entry            ,
					       copied_entry     ,
					       is_set           ,
					       propagate_column ,
					       propagate_value  )

	ELSE

		CALL_ROUTINE propagate_routine
		IN LIBRARY   global ( "current_library" )
		USING        entry           ,
			     copied_entry    ,
			     is_set          ,
			     propagate_value

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_wanted (       entries         ,
                                        VALUE count           ,
					VALUE propagate_type  ,
					VALUE component_type  ,
					VALUE category        ,
					VALUE level_id        )

{
*
*
*******************************************************************************}

	DECLARE wanted ,
		temp1  ,
		temp2  ,
		temp3  ,
	        entry

	wanted = FALSE
	entry  = entries [ count ]

	IF propagate_type = PROMPT_ON_SCHEDULE THEN

		wanted = entry . is_schedule ()

	ELSEIF propagate_type = PROMPT_ON_ANALYSIS THEN

		wanted = entry . is_analysis ()

	ELSEIF propagate_type = PROMPT_ON_COMPONENT THEN

		IF ( entry . is_component ()) OR
		   ( entry . is_textual   ()) OR
		   ( entry . is_level     ()) THEN

			IF blank ( component_type ) THEN

				temp1 = TRUE

			ELSE

				temp1 = entry . component_type =
						component_type

			ENDIF

			IF blank ( level_id ) THEN

				temp2 = TRUE

			ELSE

				temp2 = entry . level = level_id

			ENDIF

			IF category = EMPTY  THEN

				temp3 = TRUE

			ELSE

				temp3 = ( category =
				          lib_comp_get_category (
				                 entry . actual_component ))

			ENDIF

                        wanted = temp1 AND temp2 AND temp3

		ENDIF

	ENDIF

	RETURN ( wanted )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_doit (       propagate_entry ,
					    entries         ,
				      VALUE propagate_value ,
				      VALUE start_point	    ,
				      VALUE end_point       ,
				      VALUE current_column  ,
				      VALUE propagate_type  ,
				      VALUE component_type  ,
				      VALUE category        ,
				      VALUE level_id        )
{
*
*
*******************************************************************************}

	DECLARE count

	count = start_point

	WHILE count <= end_point DO

		IF work_profile_propagate_wanted ( entries        ,
		                                   count          ,
						   propagate_type ,
						   component_type ,
						   category       ,
						   level_id	  ) THEN

			work_profile_propagate_call ( entries [ count ] ,
					              propagate_entry   ,
						      propagate_value   ,
						      current_column    ,
						      TRUE              )

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_propagate_define (       form                  ,
					VALUE propagate_type        ,
					VALUE field_title           ,
					VALUE propagate_value       ,
					VALUE component_type        ,
					VALUE category              ,
					      down_only_prompt      ,
					      component_type_prompt ,
					      category_prompt       )


{
*
*
*******************************************************************************}

	DECLARE message        ,
		message_ptr    ,
		terminator     ,
		display_start  ,
		display_width  ,
		prompt_start   ,
		boolean_prompt

	display_start = 2
	display_width = 30
	prompt_start  = 35

	IF global ( "TERMTYPE" ) = "GUI" THEN

		terminator = " "

	ELSE

		terminator = ":"

	ENDIF

	PROMPT OBJECT form
	       CLASS  PROMPT_CLASS_FORM
	       ON LINE 10
	       FROM    12
	       WITH ( help_context     = "$WORK_PROFILE"               ,
	              header           = get_user_message ( "WORK_PROFILE_PROPAGATE_TITLE" ,1 ) ,
		      width            = 65                  ,
		      height           = 6                   ,
		      return_behaviour = FORM_RETURN_WRAP    )

	message = get_user_message ( "WORK_PROFILE_PROPAGATE_FIELD" , 1 )
	message = pad ( message , " " , display_width )
	message = message : terminator

	form . add_display ( message                   ,
			     display_start             ,
			     1                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )

	form . add_display ( field_title : " "         ,
			     prompt_start              ,
			     1                         ,
			     PROMPT_RENDITION_LOWERED  )

	message = get_user_message ( "WORK_PROFILE_PROPAGATE_VALUE" , 1 )
	message = pad ( message , " " , display_width )
	message = message : terminator

	form . add_display ( message                   ,
			     display_start             ,
			     2                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )

	form . add_display ( strip ( propagate_value ) : " " ,
			     prompt_start                    ,
			     2                               ,
			     PROMPT_RENDITION_LOWERED        )


	form . add_frame ( ""            ,
			   1             ,
			   1	         ,
			   2             ,
			   form . width  )



	IF global ( "TERMTYPE" ) = "GUI" THEN

		display_start = 5
		display_width = 30
   		prompt_start  = 2

	ENDIF

	message = get_user_message ( "WORK_PROFILE_PROPAGATE_DOWN" , 1 )
	message = pad ( message , " " , display_width )
	message = message : terminator

	form . add_display ( message                   ,
			     display_start             ,
			     4                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )

	message_fetch ( "WORK_PROFILE_PROPAGATE_TYPE" , message_ptr )
	message_add_parameter ( message_ptr , component_type )
	message = message_get_text ( message_ptr ,1 )

	message = pad ( message , " " , display_width )
	message = message : terminator

	form . add_display ( message                   ,
			     display_start             ,
			     5                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )


	message_fetch ( "WORK_PROFILE_PROPAGATE_CATEGORY" , message_ptr )
	message_add_parameter ( message_ptr , category )
	message = message_get_text ( message_ptr ,1 )

	message = pad ( message , " " , display_width )
	message = message : terminator

	form . add_display ( message                   ,
			     display_start             ,
			     6                         ,
			     PROMPT_RENDITION_BOLD     +
			     PROMPT_RENDITION_RAISED   )


	PROMPT OBJECT boolean_prompt
	       ON LINE 4 FROM prompt_start
	       BROWSE ON BOOLEAN
               WITH ( value    = TRUE ,
		      is_check = TRUE )

	down_only_prompt    = form . add_prompt ( boolean_prompt )

	PROMPT OBJECT boolean_prompt
	       ON LINE 5 FROM prompt_start
	       BROWSE ON BOOLEAN
               WITH ( value    = TRUE                        ,
		      is_check = TRUE                        ,
		      enabled  = NOT blank ( component_type ))

	component_type_prompt = form . add_prompt ( boolean_prompt )

	PROMPT OBJECT boolean_prompt
	       ON LINE 6 FROM prompt_start
	       BROWSE ON BOOLEAN
               WITH ( value    = TRUE                        ,
		      is_check = TRUE                        ,
		      enabled  = NOT blank ( component_type ))

	category_prompt = form . add_prompt ( boolean_prompt )

	form . add_frame ( ""            ,
			   1             ,
			   4	         ,
			   3             ,
			   form . width  )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_main ( grid )

{
*
*
*******************************************************************************}

	DECLARE form                  ,
		down_only_prompt      ,
		component_type_prompt ,
		category_prompt       ,
		start_point           ,
		end_point             ,
		propagate_type        ,
   		current_column        ,
		propagate_value       ,
		entry                 ,
		component_type        ,
		category


	component_type = ""
	category       = ""

	current_column = grid . current_column
	entry          = grid . entries [ grid . current_row ]

	IF entry . is_schedule () THEN

		propagate_type = PROMPT_ON_SCHEDULE

	ELSEIF entry . is_analysis () THEN

		propagate_type = PROMPT_ON_ANALYSIS

	ELSEIF entry . is_component () THEN

		propagate_type = PROMPT_ON_COMPONENT
		component_type = entry . component_type

		category = lib_comp_get_category ( entry . component )

	ELSEIF entry . is_level () THEN

		propagate_type = PROMPT_ON_COMPONENT
		component_type = entry . component_type

		category = lib_comp_get_category ( entry . actual_component )

	ELSE

		propagate_type = ""

	ENDIF


	work_profile_propagate_call ( entry           ,
				      entry           ,
				      propagate_value ,
				      current_column  ,
				      FALSE           )

	IF ( variable_is_assigned ( propagate_value ) ) AND
	   ( propagate_value <> ERROR                 ) THEN

		work_profile_propagate_define ( form                                               ,
						propagate_type                                     ,
						work_profile_prompt_details [ current_column , 5 ] ,
						propagate_value                                    ,
						component_type                                     ,
						category                                           ,
						down_only_prompt                                   ,
						component_type_prompt                              ,
						category_prompt                                    )

 		form . start_prompt ()
		form . wait_prompt  ()
  		form . end_prompt   ()

		IF form . get_lastkey () = "DO" THEN

			IF form . prompt_objects [ down_only_prompt ] . value THEN

				start_point = grid . current_row + 1
		     		end_point   = size_of_array ( grid . entries )

	 		ELSE

				start_point = 1
				end_point   = size_of_array ( grid . entries )

	  		ENDIF

			IF NOT form . prompt_objects [ component_type_prompt ] . value THEN

				component_type = ""

			ENDIF

			IF NOT form . prompt_objects [ category_prompt ] . value THEN

				category = EMPTY

			ENDIF

    			work_profile_propagate_doit ( entry             ,
						      grid . entries    ,
						      propagate_value   ,
						      start_point       ,
						      end_point         ,
						      current_column    ,
						      propagate_type    ,
						      component_type    ,
						      category          ,
						      ""                )
	   		grid . redisplay_column ( current_column )

  		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_propagate_button ( self )

{
*
*
*******************************************************************************}

	work_profile_propagate_main ( self . parent_prompt . user_info )


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_level_button ( self )

{
*
*
*******************************************************************************}

	DECLARE grid

	grid = self . parent_prompt . user_info

	work_profile_change_levels ( grid . level_entry_code ,
				     grid                    ,
			             grid . entries          )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_define_buttons ( VALUE mode        ,
					    button_list )

{
*
*
*******************************************************************************}

	DECLARE position

	ARRAY button_list

	position = 1

	lib_grid_lastkey_button (  button_list ,
				   position    ,
				  "DO"         ,
				   get_user_message ( "SMP_PROMPT_BUTTON_CLOSE",1 ))


	IF mode <> "DISPLAY" THEN

 		lib_grid_lastkey_button (  button_list  ,
					   position     ,
					  "INSERT HERE" ,
					   EMPTY        )

		lib_grid_lastkey_button (  button_list  ,
					   position     ,
					  "REMOVE"      ,
					   EMPTY        )

		lib_grid_action_button (  button_list                    ,
					  position                       ,
					  get_user_message ( "WORK_PROFILE_BUTTON_PROPAGATE" , 1 ) ,
					 "work_profile_propagate_button" ,
					  global ( "current_library" )   ,
			  		  position                       )


	ENDIF


	lib_grid_action_button (  button_list                    ,
		                  position                       ,
				  get_user_message ( "WORK_PROFILE_BUTTON_LEVELS" ,1 ),
				 "work_profile_level_button"     ,
			          global ( "current_library" )   ,
			  	  position                       )

	lib_grid_lastkey_button (  button_list  ,
				   position     ,
				  "HELP"        ,
				   EMPTY        )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_define_grid ( VALUE mode             ,
				   VALUE is_batch         ,
				         entries          ,
					 levels           ,
				   VALUE level_entry_code ,
					 deleted_analyses ,
				         grid_object      )

{
*
*
*******************************************************************************}

	CREATE OBJECT WORK_PROFILE_GRID  , grid_object

	grid_object . return_behaviour = GRID_RETURN_RIGHT
	grid_object . width            = 5
	grid_object . height           = global ( "SCREEN_HEIGHT" )

	grid_object . column   = 1
	grid_object . row      = 1

	grid_object . border   = FALSE

	grid_object . vgl_library          = global ( "current_library" )

	grid_object . prompt_cell_routine  = "work_profile_prompt"
	grid_object . display_cell_routine = "work_profile_display"

	IF mode = "DISPLAY" THEN

		grid_object . select_routine = "work_profile_display_select"

	ELSE

		grid_object . select_routine = "work_profile_select"
		grid_object . insert_routine = "work_profile_insert"
		grid_object . remove_routine = "work_profile_remove"

	ENDIF

	grid_object . title_separator_top   = GRID_SEPARATOR_CELLS
	grid_object . title_rendition_top   = PROMPT_RENDITION_BOLD

	grid_object . title_size_top        = 1
	grid_object . fixed_columns_left    = 2

	grid_object . cell_columns = size_of_array ( work_profile_prompt_details )
	grid_object . cell_rows    = size_of_array ( entries )

	lib_grid_setup_columns ( work_profile_prompt_details ,
				 grid_object                ,
				 "MLP_COMPONENTS"           )

	IF grid_object . cell_rows = 0 THEN

		grid_object . cell_rows    = 1

	ENDIF

	grid_object . entries          = entries
	grid_object . levels           = levels
	grid_object . level_entry_code = level_entry_code
	grid_object . deleted_analyses = deleted_analyses
	grid_object . insert_analysis  = TRUE
	grid_object . is_batch         = is_batch
	grid_object . mode             = mode

ENDROUTINE

{******************************************************************************}
{******************************************************************************}

ROUTINE work_profile_entry_action_print_others (       self  ,
					         VALUE table )

{
*
*
*******************************************************************************}

	DECLARE count       ,
		other       ,
		output_line

	count = 1

	WHILE count <= size_of_array ( work_profile_other_fields ) DO

		other = work_profile_other_fields [ count ]

		IF other <> EMPTY THEN

			IF other . allowed_for = table THEN

				output_line = PAD ( other . title , " " , 20 )
				output_line = output_line : ": "
				output_line = output_line : self . other_fields [ count ]

LITERAL
$output_line___________________________________________________________________
$ENDLITERAL

			ENDIF

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_print_replicate ( entry )

{
*
*
*******************************************************************************}


	DECLARE output_line

	SET FORMAT "9999"

	output_line = get_user_message ( "WORK_PROFILE_PRINT_REPLICATE" , 1 )
	output_line = PAD ( output_line , " " , 20 )
	output_line = output_line : ": "
	output_line = output_line : entry . replicates

LITERAL
$output_line___________________________________________________________________
$ENDLITERAL

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_print_schedule ( entry )

{
*
*
*******************************************************************************}

	DECLARE schedule ,
		temp

        temp     = get_user_message ( "WORK_PROFILE_PRINT_PROFILE" , 1 )
	schedule = entry . schedule

LITERAL

$temp___  $schedule____________________________________
--------  ---------------------------------------------

$ENDLITERAL

        entry . print_others ( PROMPT_ON_SCHEDULE )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_print_analysis ( entry )

{
*
*
*******************************************************************************}

	DECLARE analysis ,
		temp

        temp     = get_user_message ( "WORK_PROFILE_PRINT_ANALYSIS" , 1 )
	analysis = entry . analysis

LITERAL

$temp___  $analysis___________________________________
--------  --------------------------------------------
--------  --------------------------------------------

$ENDLITERAL

	work_profile_print_replicate ( entry )

	entry . print_others ( PROMPT_ON_ANALYSIS )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_print_component ( entry )

{
*
*
*******************************************************************************}

	DECLARE component    ,
		output_line

	component = entry . component

LITERAL

$component____________________________________________
------------------------------------------------------

$ENDLITERAL

	work_profile_print_replicate ( entry )

	entry . print_others ( PROMPT_ON_COMPONENT )

	output_line = get_user_message ( "WORK_PROFILE_PRINT_DP" ,1 )
	output_line = PAD ( output_line , " " , 20 ) : ": " :
		      entry . dp

LITERAL
$output_line_________________________________________________________________
$ENDLITERAL

	output_line = get_user_message ( "WORK_PROFILE_PRINT_DATATYPE" ,1 )
	output_line = PAD ( output_line , " " , 20 ) : ": " :
		      entry . component_type

LITERAL
$output_line_________________________________________________________________

$ENDLITERAL

	work_profile_print_level ( entry ,
				   TRUE  )

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_print_level (       entry        ,
				   VALUE print_header )

{
*
*
*******************************************************************************}

	DECLARE output_line ,
		temp        ,
		do_print

	output_line = entry . level

	IF entry . is_type ( "N" ) THEN

		temp        = strip ( entry . limits . display ( 1 ))
		do_print    = NOT blank (  temp )

		output_line = output_line : "   " :temp
		output_line = output_line : strip ( entry . units )
		output_line = PAD ( output_line , " " , 30 )

		IF do_print THEN

			temp        = strip ( entry . limits . display ( 2 ))

			IF NOT blank ( temp ) THEN

				output_line = output_line : "  "
				output_line = output_line : temp
				output_line = output_line : entry . units

			ENDIF

			IF print_header THEN

				temp = get_user_message ( "WORK_PROFILE_PRINT_LEVEL_N" ,1 )

LITERAL

$temp_________________________________________________________________________
$ENDLITERAL

				temp = get_user_message ( "WORK_PROFILE_PRINT_LEVEL_N" ,2 )

LITERAL
$temp_________________________________________________________________________
$ENDLITERAL

	                ENDIF

			IF do_print THEN

LITERAL
$output_line___________________________________________________________________
$ENDLITERAL

			ENDIF

		ENDIF

	ELSEIF entry . is_type ( "T" ) THEN

		IF ( print_header                       ) AND
		   ( NOT blank ( entry . textual_value )) THEN

				temp = get_user_message ( "WORK_PROFILE_PRINT_LEVEL_T" ,1 )

LITERAL

$temp_________________________________________________________________________
$ENDLITERAL

				temp = get_user_message ( "WORK_PROFILE_PRINT_LEVEL_T" ,2 )

LITERAL
$temp_________________________________________________________________________
$ENDLITERAL



		ENDIF

		IF NOT blank ( entry . textual_value ) THEN

			output_line = output_line : PAD ( entry . textual_value , " " , 30 )
			output_line = output_line : entry . comparison

LITERAL
$output_line__________________________________________________________________
$ENDLITERAL

		ENDIF

	ELSE

		output_line = output_line : " " :
			      substring	( entry . limits . display ( 1 ) ,1  , 20 )

		output_line = output_line : " " :
			      substring	( entry . limits . display ( 2 ) ,1 , 20 )

LITERAL
$output_line_________________________________________________________________
$ENDLITERAL

	ENDIF


ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_print_textual ( entry )

{
*
*
*******************************************************************************}

	DECLARE output_line

	output_line = PAD ( " " , " " , 10 )
	output_line = output_line : PAD ( entry . textual_value , " " , 30 )
	output_line = output_line : entry . comparison

LITERAL
$output_line__________________________________________________________________
$ENDLITERAL

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_print ( work_profile_entries )

{
*
*
*******************************************************************************}

	DECLARE count ,
		entry

	count = 1

	WHILE count <= size_of_array ( work_profile_entries ) DO

		entry = work_profile_entries [ count ]

		IF entry . is_schedule () THEN

			work_profile_print_schedule ( entry )

		ELSEIF entry . is_analysis () THEN

			work_profile_print_analysis ( entry )

		ELSEIF entry . is_component () THEN

			work_profile_print_component ( entry )

		ELSEIF entry . is_level () THEN

			work_profile_print_level ( entry ,
						   FALSE )

		ELSEIF entry . is_textual () THEN

			work_profile_print_textual ( entry )

		ENDIF


		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_modify ( VALUE spec_header ,
		              VALUE mlp_version ,
			      VALUE mode        ,
			      VALUE is_batch    )
{
*
*
*******************************************************************************}

	DECLARE form             ,
		grid             ,
		button_list      ,
		button_list1     ,
		can_leave        ,
		goto_column      ,
		goto_row         ,
		header_message   ,
		message          ,
	        curr_help        ,
		continue

	continue = TRUE

	IF NOT work_profile_got_data ( work_profile_entries ) THEN

		work_profile_initialise ( is_batch )

		continue = work_profile_read_data ( spec_header                 ,
		                                    mlp_version                 ,
		                                    mode                        ,
		                                    is_batch                    ,
		                                    work_profile_entries        ,
		                                    work_profile_level_entrycode,
		                                    work_profile_levels         ,
		                                    work_profile_all_locked     )

	ENDIF

	IF ( NOT continue ) THEN

		{**************************************************************}
		{ Dont Do Anything, user did not specify Levels                }
		{**************************************************************}

		work_profile_entries = EMPTY

	ELSEIF work_profile_all_locked THEN

		IF mode = "DISPLAY" THEN

			SET DISPLAY TRUE

		ENDIF

		work_profile_define_buttons ( mode        ,
					      button_list )

		work_profile_define_grid ( mode                          ,
					   is_batch                      ,
					   work_profile_entries          ,
					   work_profile_levels           ,
				           work_profile_level_entry_code ,
					   work_profile_deleted_analyses ,
				           grid                          )

		IF mode = "DISPLAY" THEN

  			message_fetch ( "WORK_PROFILE_DISP_HEADER" ,
			                 header_message )
  			message_fetch ( "WORK_PROFILE_DISP_FOOTER" ,
			                 message )

		ELSE

  			message_fetch ( "WORK_PROFILE_MOD_HEADER" ,
			                 header_message )
  			message_fetch ( "WORK_PROFILE_MOD_FOOTER" ,
			                 message )

		ENDIF

		message_add_parameter ( header_message , strip ( spec_header ))

 		lib_grid_create_form  ( grid                                  ,
					form                                  ,
					mode <> "DISPLAY"                     ,
					0                                     ,
		                        message_get_text ( header_message, 1 ),
		                        message_get_text ( message, 1 )       ,
	        	                button_list1                          )

		curr_help = GLOBAL ( "STD_EDITOR_HELP" )

		IF is_batch THEN
			SET GLOBAL "STD_EDITOR_HELP" TO "$BATCH_TMPL_RESULTS"
			form . help_context = "$BATCH_TMPL_RESULTS"
		ELSE
			SET GLOBAL "STD_EDITOR_HELP" TO "$WORK_PROFILE_MAIN"
			form . help_context = "$WORK_PROFILE_MAIN"
		ENDIF

		form . user_info = grid

		lib_form_add_vertical_buttons ( form        ,
						button_list )

		form . start_prompt ()

      		grid . set_position ( 2, 1 )

		REPEAT

			form . wait_prompt  ()

			IF mode = "DISPLAY" THEN

				can_leave = TRUE

			ELSE

				IF work_profile_data_valid ( work_profile_entries ,
				 		             goto_column          ,
						             goto_row             ) THEN

					can_leave = TRUE

				ELSE

					grid . set_position ( goto_column ,
							      goto_row    )
					can_leave = FALSE

				ENDIF

			ENDIF

		UNTIL can_leave

		form . end_prompt   ()

		SET GLOBAL "STD_EDITOR_HELP" TO curr_help

		SET DISPLAY FALSE

	ELSE

		flash_message ( get_user_message ( "WORK_PROFILE_LOCKED" , 1 ),
				 TRUE                                        )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE work_profile_main ( VALUE spec_header ,
			    VALUE copy_spec   ,
			    VALUE mode        ,
			    VALUE is_batch    )
{
*
*
*******************************************************************************}

	DECLARE mlp_version

	IF ( mode = "COPY"  ) THEN

		work_profile_mlp_version ( copy_spec, mlp_version )

		work_profile_initialise ( is_batch )

		ASSIGN mlp_header . entry_code    = 0
		{ASSIGN mlp_header . test_schedule = ""}

		work_profile_read_data ( copy_spec                     ,
				         mlp_version                   ,
				         mode                          ,
					 is_batch                      ,
					 work_profile_entries          ,
					 work_profile_level_entry_code ,
			   		 work_profile_levels           ,
					 work_profile_all_locked       )

		extract_mlp_version ( mlp_version, spec_header )

		ASSIGN mlp_header . test_schedule = work_profile_spec_header_to_test_sched ( spec_header )

	ELSEIF ( mode = "MODIFY"  ) OR
	       ( mode = "DISPLAY" )	THEN

		ASSIGN mlp_header . test_schedule = work_profile_spec_header_to_test_sched ( spec_header )

		IF NOT work_profile_mlp_version_no_message ( spec_header, mlp_version ) THEN
			mlp_version = packed_decimal ( 1 )
		ENDIF

		work_profile_modify ( spec_header ,
				      mlp_version ,
				      mode        ,
				      is_batch    )

	ELSEIF ( mode = "PRINT"  ) THEN

		ASSIGN mlp_header . test_schedule = work_profile_spec_header_to_test_sched ( spec_header )

		work_profile_mlp_version ( spec_header, mlp_version )

		work_profile_initialise ( is_batch )

		work_profile_read_data ( spec_header                   ,
				         mlp_version                   ,
					 mode                          ,
					 is_batch                      ,
					 work_profile_entries          ,
					 work_profile_level_entry_code ,
			   		 work_profile_levels           ,
					 work_profile_all_locked       )

		work_profile_print ( work_profile_entries )


	ELSEIF ( mode = "SAVE" ) THEN

                extract_mlp_version ( mlp_version, spec_header )

		IF ( mlp_version = EMPTY ) OR BLANK ( mlp_version ) OR 
		   ( ( mlp_version = 0 ) AND ( is_batch = TRUE ) ) THEN
			IF NOT work_profile_mlp_version_no_message ( spec_header, mlp_version ) THEN
				mlp_version = packed_decimal ( 1 )
			ENDIF
		ENDIF

		IF ( work_profile_got_data ( work_profile_entries )) AND
		   ( work_profile_all_locked                      ) THEN

			work_profile_update_data ( spec_header                   ,
						   mlp_version                   ,
						   is_batch                      ,
						   work_profile_entries          ,
						   work_profile_level_entry_code ,
						   work_profile_levels           ,
						   work_profile_deleted_analyses )

			work_profile_entries = EMPTY


		ENDIF

	ELSEIF ( mode = "QUIT" ) THEN

		work_profile_entries = EMPTY

	ENDIF

	RETURN ( transaction_has_updates ())

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_labtable_input ( VALUE spec_header ,
			              VALUE copy_spec   ,
			              VALUE mode        )
{
*
*
*******************************************************************************}

	work_profile_main ( spec_header ,
			    copy_spec   ,
			    mode        ,
			    FALSE       )

	RETURN ( transaction_has_updates ())

ENDROUTINE


{******************************************************************************}

ROUTINE work_profile_batch_result_input ( VALUE spec_header ,
			                  VALUE copy_spec   ,
			                  VALUE mode        )
{
*
*
*******************************************************************************}

	DECLARE temp     ,
		valid    ,
		size

	GET_FIELD_DETAILS mlp_header . identity
			  "FIELD_SIZE"    ,
			   size

	spec_header = pad ( spec_header , " " , size )
	copy_spec   = pad ( copy_spec   , " " , size )


	valid = TRUE

	IF mode = "MODIFY" THEN

		IF blank ( SELECT batch_tmpl_header . analysis ) THEN


			valid = FALSE

			flash_message  ( get_user_message ( "WORK_PROFILE_BATCH_NO_ANALYSIS" , 1 ),
					 TRUE                                                    )

		ENDIF

	ENDIF

	IF valid THEN

		IF SELECT mlp_header . identity <> spec_header THEN

			IF mode <> "READ_FOR_DISPLAY" THEN

				temp = SELECT mlp_header . identity
				       FOR UPDATE
				       WHERE ( identity = spec_header )
				       ORDER ON product_version DESCENDING

			ELSE

				temp = SELECT mlp_header . identity
				       WHERE ( identity = spec_header )
				       ORDER ON product_version DESCENDING


    			ENDIF

			IF temp = EMPTY THEN

				RESERVE ENTRY mlp_header , spec_header : PACKED_DECIMAL ( 1 )

	   		ENDIF

  		ENDIF

		IF mode = "SAVE" THEN

			ASSIGN mlp_header . description = SELECT batch_tmpl_header . description
  			ASSIGN mlp_header . group_id    = SELECT batch_tmpl_header . group_id

			ASSIGN mlp_header . modified_on = now
			ASSIGN mlp_header . modified_by = operator

		ENDIF

		work_profile_main ( spec_header ,
				    copy_spec   ,
				    mode        ,
	    			    TRUE        )

		IF ( mode = "SAVE" ) THEN

			{ Dont create an MLP with an invalid entry_code }

			IF 0 = SELECT mlp_header . entry_code THEN
				ASSIGN mlp_header . entry_code = level_get_entry_code ()
			ENDIF

			UPDATE mlp_header
			NEXT mlp_header { Knock the pointer out }

		ENDIF

		IF ( mode = "QUIT" ) THEN

			NEXT mlp_header { Knock the pointer out }

  		ENDIF

	ENDIF

	RETURN ( transaction_has_updates ())

ENDROUTINE



